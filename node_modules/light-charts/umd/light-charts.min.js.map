{"version":3,"sources":["webpack://ReactLoadingButton/webpack/universalModuleDefinition","webpack://ReactLoadingButton/webpack/bootstrap","webpack://ReactLoadingButton/external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}","webpack://ReactLoadingButton/./src/exports/Test/index.js","webpack://ReactLoadingButton/./src/colors/light.js","webpack://ReactLoadingButton/./src/utils/common.js","webpack://ReactLoadingButton/./src/exports/KLine/index.js","webpack://ReactLoadingButton/./src/exports/Bar/index.js","webpack://ReactLoadingButton/./src/exports/Line/index.js"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_default","_Component","apply","arguments","render","React","createElement","Component","COLOR","TEXT_COLOR","BG_COLOR","BORDER_COLOR","LINE_COLOR","setCanvasSize","canvasEl","style","gridWidth","gridHeight","ctx","getContext","width","slice","height","ratio","getPixelRatio","scale","renderLine","sx","sy","ex","ey","lineColor","lineWidth","BLACK","beginPath","moveTo","lineTo","strokeStyle","stroke","closePath","renderText","x","y","text","align","color","font","fillStyle","textBaseline","textAlign","fillText","yAxisTickText","maxValue","minValue","yAxisHeight","fractionDigits","toFixed","xAxisTickPointX","xAxisPointX","xAxisItemWidth","valueHeight","context","backingStore","backingStorePixelRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","devicePixelRatio","mergeObject","target","res","toString","Point","drawRoundedRect","rect","ptA","ptB","ptC","ptD","ptE","arcTo","memo","_ref","_ref$option","option","loadData","_ref$style","config","avgList","showTips","canDrag","canScroll","pageSize","maxShowSize","yAxisSplitNumber","backgroundColor","xAxisItemMaxShowNumber","grid","left","right","top","bottom","axisTick","length","show","tickLength","_useState","useState","map","Map","colorMap","5","10","20","forEach","day","set","curVal","list","MAList","setMAList","dataSource","leftDataSource","rightDataSource","canvasWidth","canvasHeight","yAxisOriginPointY","yAxisTickSpace","xAxisVertexX","xAxisWidth","init","originalPointX","yAxisVertexY","xAxisItemLength","candleWidth","renderCandle","dataItem","xAxisItemPointX","candleWidthHalf","highestPrice","lowestPrice","openingPrice","closingPrice","secondPointY","undefined","thirdPointY","candleColor","fill","renderTipCanvas","console","log","tipCanvas","document","getElementById","ctxTip","maxPrice","Math","max","minPrice","min","addEventListener","e","offsetX","offsetY","clearRect","isContentArea","setLineDash","xyAxisTipBoxHeight","xyAxisTipBoxWidth","xTipIndex","round","date","_step","_iterator","_createForOfIteratorHelperLoose","done","_step$value","innerText","marginTop","tipInfoPointX","globalAlpha","_dataSource$xTipIndex","label","concat","_ref2","getDrag","horizontalDragDistance","insertPosition","lastPosition","event","abs","cursor","unshift","pop","push","shift","renderCanvas","draggableNode","display","then","kWrapNode","div","position","zIndex","setAttribute","appendChild","getScroll","timer","deltaX","deltaY","Date","now","clearTimeout","setTimeout","warn","tranPriceToOrdinate","price","dataYAxisPoint","it","newIt","remainder","ceil","xAxisTickX","_step2","renderBezierCurve","controlPoint","_controlPoint$_i","curX","curY","prevControlX","prevControlY","prevNode","bezierCurveTo","nextControlX","nextControlY","getMAControlPointInfo","_MAList","totalOpenPrice","reduce","prev","item","_extends","getMA","pricePointX","pricePointY","nextNode","triangleHeight","triangleBottomLine","triangleHypotenuse","sqrt","pow","controlPointW","controlPointBottomLine","controlPointHeight","_iterator2","_step2$value","obj","candleLength","j","oneByOneRenderCandle","renderCandles","useLayoutEffect","tipCanvasEl","_setCanvasSize","data","error","Fragment","className","_MAList$get","id","Bar","yData","xData","_config$axisTick","axisTickShow","originalPointY","xAxisTopPointX","floor","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","padding_horizontal","barWidth","dataPoint","itemSpace","_dataPoint$_i","h","Line","axisTickLength","xAxisItemSpace","xAxisItemSpaceHalf","_dataPoint","nextX","nextY","arc","PI"],"mappings":"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","file":"light-charts.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactLoadingButton\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"ReactLoadingButton\"] = factory(root[\"React\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import React, {Component} from 'react'\n\nexport default class extends Component {\n  render() {\n    return <div>\n      <h2>Welcome to React components</h2>\n    </div>\n  }\n}\n","const COLOR = {\n  PRIMARY: '#207BF7',\n  RED: '#FF3333',\n  GREEN: '#46B262',\n  LINE: '#FDFDFD',\n  TIP_LINE: '#727183',\n  WHITE: '#FFF',\n  BLACK: '#000',\n}\nconst TEXT_COLOR = {\n  PRIMARY: '#333',\n  SECOND: '#666',\n  RED: '#FF3333',\n}\nconst BG_COLOR = {\n  // 背景色：整体背景颜色\n  BODY: '#FFFFFF',\n  // 前景色：和整体背景色对比\n  COMPONENT: '#F3F5FB'\n}\nconst BORDER_COLOR = {\n  PRIMARY: '#C5C5C5',\n  SECOND: '#C9C9C9'\n}\nconst LINE_COLOR = {\n  YELLOW: '#FAB339',\n  ORANGE: '#FF752A',\n  BLUE: '#207BF7',\n}\nexport {\n  COLOR,\n  TEXT_COLOR,\n  BG_COLOR,\n  BORDER_COLOR,\n  LINE_COLOR,\n}","/**\n * 设置容器和画布宽高，并返回画布宽高\n * @param {object} canvasEl canvas元素\n * @param {object} style 容器样式「宽、高」\n * @param {string | number} gridWidth grid组件的宽度 auto | 0-1（百分比，1代表100%）\n * @param {string | number} gridHeight grid组件的高度 auto | 0-1\n * @returns object 宽高\n */\nexport const setCanvasSize = (canvasEl, style, gridWidth = 'auto', gridHeight = 'auto') => {\n  const ctx = canvasEl.getContext('2d')\n  const width = +style.width.slice(0, -2)\n  const height = +style.height.slice(0, -2)\n\n  // 设置css样式\n  canvasEl.style.width = width + 'px'\n  canvasEl.style.height = height + 'px'\n\n  // 解决不同视网膜屏幕下「像素比不一致」，文字、样式的模糊问题\n  // 获取像素比，对画布大小和上下文进行缩放\n  const ratio = getPixelRatio(ctx)\n\n  // 1.对画布大小「宽高」进行缩放\n  canvasEl.width = width * ratio\n  canvasEl.height = height * ratio\n\n  // 2.对画布水平、垂直方向的单位进行缩放（注意：从某些方面说, scale() 缩放的不是画布，而是画布上 1 个单位的距离）\n  ctx.scale(ratio, ratio)\n\n  return {\n    width: gridWidth === 'auto' ? width : width * gridWidth,\n    height: gridHeight === 'auto' ? height : height * gridWidth,\n  }\n}\n\n/**\n   * 绘制线条\n   * @param {number} ctx 上下文\n   * @param {number} sx 开始坐标点横坐标\n   * @param {number} sy 开始坐标点纵坐标\n   * @param {number} ex 结束坐标点横坐标\n   * @param {number} ey 结束坐标点纵坐标\n   * @param {string} lineColor 线条颜色\n   * @param {number} lineWidth 线条宽度\n   */\nexport const renderLine = (ctx, sx, sy, ex, ey, lineColor = COLOR.BLACK, lineWidth = 0.2) => {\n  ctx.beginPath()\n  ctx.moveTo(sx, sy)\n  ctx.lineTo(ex, ey)\n  ctx.strokeStyle = lineColor\n  ctx.lineWidth = lineWidth\n  ctx.stroke()\n  ctx.closePath();\n}\n\n/**\n   * 绘制文字\n   * @param {object} ctx 上下文\n   * @param {number} x 横坐标\n   * @param {number} y 纵坐标\n   * @param {string} text 文本\n   * @param {string} align 文本对齐方式\n   * @param {string} color 文本颜色\n   */\nexport const renderText = (ctx, x, y, text, align = 'left', color = '#FFF', font = '12px') => {\n  ctx.fillStyle = color;  // 文字颜色\n  ctx.textBaseline = \"middle\";\n  ctx.textAlign = align;\n\n  ctx.font = `${font} Arial`;  // 大小、字体\n  ctx.fillText(text, x, y)  // 描绘实体文字\n}\n\n/**\n * 计算Y轴刻度对应的数值：根据最大最小值动态变化\n * @param {number} height y轴刻度的高度\n * @param {number} maxValue 最大值\n * @param {number} minValue 最小值\n * @param {number} yAxisHeight y轴高度\n * @param {number} fractionDigits 保留几位小数\n * @returns number 刻度对应的数值\n */\nexport const yAxisTickText = (height, maxValue, minValue, yAxisHeight, fractionDigits = 2) => {\n  // value 与 y轴高度的比例\n  const ratio = (maxValue - minValue) / yAxisHeight\n  const value = (minValue + height * ratio).toFixed(fractionDigits)\n  return value\n}\n\n/**\n * 求x轴刻度横坐标\n * @param {number} i 下标\n * @param {number} xAxisPointX x轴原点横坐标\n * @param {number} xAxisItemWidth x轴元素宽度\n * @returns number x轴刻度横坐标\n */\nexport const xAxisTickPointX = (i, xAxisPointX, xAxisItemWidth) => {\n  return xAxisPointX + i * xAxisItemWidth\n}\n\n/**\n * 求该值在y轴高度中的所占的高度值\n * @param {number} value 数值\n * @param {number} maxValue 最大值\n * @param {number} minValue 最小值\n * @param {number} yAxisHeight y轴高度\n * @returns number 该数值的对应高度\n */\nexport const valueHeight = (value, maxValue, minValue, yAxisHeight) => {\n  // 每块钱占自定义坐标系的高度\n  const rate = yAxisHeight / (maxValue - minValue)\n  // 当前价格占自定义坐标系的高度\n  const h = rate *  (value - minValue)\n  return h;\n}\n\n/**\n   * 绘制矩形\n   * @param {object} ctx 上下文\n   * @param {number} x 横坐标\n   * @param {number} y 纵坐标\n   * @param {number} width 宽度\n   * @param {number} height 高度\n   * @param {string} color 颜色\n   */\nexport const renderRect = (ctx, x, y, width = 20, height, color) => {\n  ctx.beginPath()\n  ctx.moveTo(x, y)\n  ctx.rect(x, y, width, height)\n  ctx.fillStyle = color\n  ctx.fill();\n}\n\n/**\n * 返回像素比\n * @param {object} context 渲染上下文\n * @returns number\n */\nexport const getPixelRatio = function (context) {\n  var backingStore = context.backingStorePixelRatio ||\n      context.webkitBackingStorePixelRatio ||\n      context.mozBackingStorePixelRatio ||\n      context.msBackingStorePixelRatio ||\n      context.oBackingStorePixelRatio ||\n      context.backingStorePixelRatio || 1;\n  return (window.devicePixelRatio || 1) / backingStore;\n};\n\n/**\n * 深度合并对象\n * @param {object} object 默认对象\n * @param {object} target 目标对象\n */\nexport const mergeObject = (object = {}, target = {}) => {\n  const res = {}\n  for (const key in object) {\n    if (Object.prototype.toString.call(target[key]) === '[object Object]') {\n      res[key] = mergeObject(object[key], target[key])\n    } else {\n      res[key] = target[key] || object[key]\n    }\n  }\n  return res;\n}\n\n\nconst Point = (x, y) => ({ x, y });\n/**\n * 绘制圆角矩形\n * @param {function} rect 矩形函数\n * @param {number} r 圆角半径\n * @param object ctx\n */\nexport const drawRoundedRect = (rect, r, ctx) => {\n  var ptA = Point(rect.x + r, rect.y);\n  var ptB = Point(rect.x + rect.width, rect.y);\n  var ptC = Point(rect.x + rect.width, rect.y + rect.height);\n  var ptD = Point(rect.x, rect.y + rect.height);\n  var ptE = Point(rect.x, rect.y);\n\n  ctx.beginPath();\n\n  ctx.moveTo(ptA.x, ptA.y);\n  ctx.arcTo(ptB.x, ptB.y, ptC.x, ptC.y, r);\n  ctx.arcTo(ptC.x, ptC.y, ptD.x, ptD.y, r);\n  ctx.arcTo(ptD.x, ptD.y, ptE.x, ptE.y, r);\n  ctx.arcTo(ptE.x, ptE.y, ptA.x, ptA.y, r);\n\n  ctx.stroke();\n}","import React, { useLayoutEffect, useState } from 'react'\nimport './index.css';\n\nimport { COLOR, TEXT_COLOR, BG_COLOR, BORDER_COLOR, LINE_COLOR } from '../../colors/light';\nimport { renderLine, xAxisTickPointX, valueHeight, renderText, yAxisTickText, setCanvasSize, mergeObject, drawRoundedRect } from '../../utils/common';\n\nconst KLine = ({ option = {}, loadData, style = { width: '600px', height: '300px' } }) => {\n  // 默认配置项\n  const defaultConfig = {\n    // 均线类型\n    avgList: [5, 10, 20],\n    // 是否绘制辅助线\n    showTips: true,\n    // 是否可以拖拽\n    canDrag: true,\n    // 是否可缩放\n    canScroll: true,\n    pageSize: 40,\n    // 最多一页展示多少条数据（最多maxShowSize条）\n    maxShowSize: 80,\n    // 基础默认配置\n    // y轴分段数量\n    yAxisSplitNumber: 4,\n    // 背景色\n    backgroundColor: BG_COLOR.BODY,\n    // x轴元素「文字和刻度」最大展示个数\n    xAxisItemMaxShowNumber: 5,\n    // 坐标轴与容器间的边距\n    grid: {\n      left: 30,\n      right: 30,\n      top: 20,\n      bottom: 20,\n      height: 'auto',\n      width: 'auto',\n    },\n    // 刻度相关\n    axisTick: {\n      length: 5,\n      show: true,\n    },\n  }\n\n  const config = mergeObject(defaultConfig, option)\n  const { yAxisSplitNumber, grid, axisTick: { length: tickLength }, avgList, showTips, canDrag, canScroll, pageSize, maxShowSize, backgroundColor, xAxisItemMaxShowNumber } = config;\n\n  const [MAList, setMAList] = useState(() => {\n    const map = new Map([]);\n    const colorMap = {\n      5: LINE_COLOR.YELLOW,\n      10: LINE_COLOR.ORANGE,\n      20: LINE_COLOR.BLUE,\n    }\n    avgList.forEach(day => {\n      map.set(day, { color: colorMap[day], curVal: '', list: [] })\n    })\n    return map\n  }) // 平均线集合)\n\n  // 因为该函数只能执行一次，我们想要更新数据，又想要拿到上次的值，所以使用useRef\n  // 如果能确保只执行一次，使用普通变量也可以，不能确保的话，使用useRef\n  let dataSource = []\n  let leftDataSource = []\n  let rightDataSource = []\n\n  // 初始变量：因为使用了React.memo,所以该函数只会执行一次，那么这些变量可以放在函数内部\n  // TODO: ctx 放在useRef里\n  let ctx = ''\n  let canvasWidth = ''\n  let canvasHeight = ''\n  let yAxisOriginPointY = '' // y轴原点纵坐标\n  let yAxisHeight = ''  // y轴高度\n  let yAxisTickSpace = '' // y轴刻度间距\n  let xAxisVertexX = '' // x轴顶点横坐标\n  let xAxisWidth = '' // x轴宽度\n  let init = true\n\n  // 初始常量\n  const originalPointX = grid.left // 原点横坐标\n  const yAxisVertexY = grid.top // y轴顶点纵坐标\n\n  // 随画布元素数量变化而变化的属性\n  let xAxisItemWidth = '' // // x轴元素宽度\n  let xAxisItemLength = pageSize\n  let candleWidth = ''  // 蜡烛宽度\n\n\n  /**\n   * 绘制一串蜡烛（更新阶段）\n   * @param {array} dataYAxisPoint 数据源\n   * @param {number} candleWidth 蜡烛宽度\n   */\n  const renderCandles = (dataYAxisPoint, candleWidth) => {\n    for (let i = 0, candleLength = dataYAxisPoint.length; i < candleLength; i++) {\n      renderCandle(dataYAxisPoint[i], xAxisTickPointX(i, originalPointX, xAxisItemWidth), candleWidth)\n    }\n  }\n\n  /**\n   * 逐个渲染一串蜡烛（首次加载阶段）\n   */\n  const oneByOneRenderCandle = (dataYAxisPoint, candleWidth) => {\n    for(let i = 0, candleLength = dataYAxisPoint.length; i < candleLength; i++) {\n      (function(j) {\n        setTimeout(() => {\n          renderCandle(dataYAxisPoint[j], xAxisTickPointX(j, originalPointX, xAxisItemWidth), candleWidth)\n        }, j * 100)\n      }(i))\n    }\n  }\n\n  /**\n   * 绘制单个蜡烛\n   * @param {number} dataItem 当前元素数据\n   * @param {number} xAxisItemPointX 蜡烛横坐标\n   * @param {number} candleWidth 蜡烛宽度\n   */\n  const renderCandle = (dataItem, xAxisItemPointX, candleWidth) => {\n    const candleWidthHalf = candleWidth / 2\n\n    const { highestPrice, lowestPrice, openingPrice, closingPrice } = dataItem\n    let secondPointY = undefined;\n    let thirdPointY = undefined;\n    let candleColor = undefined;\n\n    if (closingPrice < openingPrice) {\n      // 涨\n      candleColor = COLOR.RED\n      secondPointY = closingPrice\n      thirdPointY = openingPrice\n    } else {\n      candleColor = COLOR.GREEN\n      secondPointY = openingPrice\n      thirdPointY = closingPrice\n    }\n\n    // 绘制蜡烛上影线\n    renderLine(ctx, xAxisItemPointX, highestPrice, xAxisItemPointX, secondPointY, candleColor, 1)\n\n    // 绘制蜡烛下影线\n    renderLine(ctx, xAxisItemPointX, lowestPrice, xAxisItemPointX, thirdPointY, candleColor, 1)\n\n    // 绘制蜡烛实体（绘制矩形）\n    ctx.beginPath()\n    ctx.moveTo(xAxisItemPointX - candleWidthHalf, secondPointY)\n    ctx.rect(xAxisItemPointX - candleWidthHalf, secondPointY, candleWidth, thirdPointY - secondPointY)\n    ctx.fillStyle = candleColor\n\n    if (candleColor === COLOR.RED) {\n      ctx.stroke()\n    } else {\n      ctx.fill();\n    }\n  }\n\n  /**\n   * 绘制辅助线画布\n   */\n  const renderTipCanvas = () => {\n    console.log('绘制辅助线画布');\n    const tipCanvas = document.getElementById('tipCanvas');\n    const ctxTip = tipCanvas.getContext('2d');\n\n    const maxPrice = Math.max(...dataSource.map(x => x.highestPrice)) + 5\n    const minPrice = Math.min(...dataSource.map(x => x.lowestPrice)) - 5\n\n    // 提示框内部样式配置\n    const padding_horizontal = 10;\n    const padding_vertical = 20;\n    const item_space = 20;\n\n    // 提示框元素宽度\n    let tipInfoElWidth = 100\n    // 提示框高度\n    let tipInfoElHeight = 120\n    // x轴y轴上的提示背景框的宽、高\n    const xyAxisTipBoxWidth = 50\n    const xyAxisTipBoxHeight = 20\n\n    // 判断鼠标是否在k线图内容区域\n    const isContentArea = (e) => {\n      const { offsetX, offsetY } = e\n      return  offsetX > originalPointX - candleWidth/2 &&\n              offsetX < canvasWidth + candleWidth/2 - grid.right - xAxisWidth / xAxisItemLength &&\n              offsetY > grid.top &&\n              offsetY < yAxisOriginPointY\n    }\n\n    // 监听鼠标移动事件并绘制辅助线\n    tipCanvas.addEventListener('mousemove', function (e) {\n      // 鼠标距目标节点左上角的X坐标、Y坐标\n      const { offsetX, offsetY } = e\n      // 清除画布\n      ctxTip.clearRect(0, 0, canvasWidth, canvasHeight)\n      // 不在内容区域则不进行绘制\n      if (!isContentArea(e)) return\n\n      // 绘制水平辅助线\n      ctxTip.beginPath();\n      ctxTip.setLineDash([3, 3]); // 设置虚线样式\n      ctxTip.moveTo(originalPointX, offsetY);\n      ctxTip.lineTo(canvasWidth - grid.right - xAxisWidth / xAxisItemLength, offsetY);\n      ctxTip.strokeStyle = BORDER_COLOR.SECOND\n      ctxTip.stroke();\n\n      // 绘制垂直辅助线\n      ctxTip.beginPath();\n      ctxTip.setLineDash([3, 3]);\n      ctxTip.moveTo(offsetX, grid.top);\n      ctxTip.lineTo(offsetX, yAxisOriginPointY);\n      ctxTip.strokeStyle = BORDER_COLOR.PRIMARY\n      ctxTip.stroke();\n\n      // 绘制y轴tip文字背景框\n      ctxTip.beginPath();\n      ctxTip.rect(originalPointX, offsetY - xyAxisTipBoxHeight / 2, xyAxisTipBoxWidth, xyAxisTipBoxHeight);\n      ctxTip.fillStyle = BORDER_COLOR.SECOND\n      ctxTip.fill();\n\n      // 绘制y轴tip文字\n      renderText(ctxTip, originalPointX + 25, offsetY, yAxisTickText(yAxisOriginPointY - offsetY, maxPrice, minPrice, yAxisHeight), 'center', COLOR.WHITE)\n\n      // 绘制x轴tip文字背景框\n      ctxTip.beginPath();\n      ctxTip.rect(offsetX - xyAxisTipBoxWidth / 2, yAxisOriginPointY, xyAxisTipBoxWidth, xyAxisTipBoxHeight);\n      ctxTip.fillStyle = BORDER_COLOR.SECOND\n      ctxTip.fill();\n\n      // 绘制x轴tip文字\n      // 获取x轴元素在x轴上的下标\n      const xTipIndex = Math.round((offsetX - originalPointX) / xAxisWidth * xAxisItemLength)\n      renderText(ctxTip, offsetX, yAxisOriginPointY + xyAxisTipBoxHeight / 2, dataSource.map((x) => x.date)[xTipIndex] || '', 'center', COLOR.WHITE);\n\n      // 更新均线值\n      for (let [day, obj] of MAList)  {\n        const curVal = obj.list[xTipIndex]\n        document.getElementById(`avg${day}`).innerText = `MA${day} ${curVal}`\n      }\n\n      // 绘制提示框\n      const dist = 10 // 提示框距离鼠标的距离\n      const marginTop = yAxisVertexY + 30 // 提示框距离画布顶部的距离\n      let tipInfoPointX = offsetX + dist  //  提示框的开始横坐标\n      // TODO\n      if (offsetX >  (canvasWidth / 2 - grid.left)) {\n        // if (xTipIndex > xAxisItemLength / 2) {\n        tipInfoPointX = offsetX - tipInfoElWidth - dist\n      }\n      ctxTip.beginPath()\n      drawRoundedRect({\n        x: tipInfoPointX,\n        y: marginTop,\n        width: tipInfoElWidth,\n        height: tipInfoElHeight\n      }, 10, ctxTip)\n      ctxTip.fillStyle = BG_COLOR.COMPONENT\n      ctxTip.globalAlpha = 0.9\n      ctxTip.fill();\n\n      const { date, highestPrice, lowestPrice, openingPrice, closingPrice } = dataSource[xTipIndex]\n      const dataArr = [\n        { label: '开盘', value: openingPrice },\n        { label: '收盘', value: closingPrice },\n        { label: '最高', value: highestPrice },\n        { label: '最低', value: lowestPrice },\n      ]\n      const cloneDataArr = [{ label: '时间', value: date }, ...dataArr];\n      // 绘制提示框内的元素\n      cloneDataArr.forEach(({ label, value }, i) => {\n        const y = marginTop + padding_vertical + i * item_space;\n        renderText(ctxTip, tipInfoPointX + padding_horizontal, y, label, 'left', TEXT_COLOR.PRIMARY, '13px')\n        renderText(ctxTip, tipInfoPointX + tipInfoElWidth - padding_horizontal, y, value, 'right', i !== 0 ? TEXT_COLOR.PRIMARY : TEXT_COLOR.RED, '13px')\n      })\n    }, false)\n  }\n\n  // 拖拽\n  const getDrag = () => {\n    // 水平拖动距离\n    let horizontalDragDistance = 0\n    // 插入数据时的光标位置\n    let insertPosition = 0\n    // 光标的上一个位置，用于判断拖动方向\n    let lastPosition = ''\n\n    /* 开始拖动目标元素时触发dragstart事件 */\n    document.addEventListener(\"dragstart\", function( event ) {\n      // 清除提示画布\n      const tipCanvas = document.getElementById('tipCanvas');\n      const ctxTip = tipCanvas.getContext('2d');\n      ctxTip.clearRect(0, 0, canvasWidth, canvasHeight)\n\n      insertPosition = event.offsetX\n      lastPosition = event.offsetX\n    }, false);\n\n    /* 拖动目标元素时触发drag事件 */\n    document.addEventListener(\"drag\", function( event ) {\n      const { offsetX } = event\n\n      // TODO 不清楚小于0的场景,是被display: none的原因吗??\n      if (offsetX < 0) return\n\n      // 计算水平拖动距离\n      horizontalDragDistance = Math.abs(offsetX - insertPosition)\n\n      const draggableNode = document.getElementById('draggable')\n      draggableNode.style.cursor = 'grabbing'\n\n      // 如果拖动距离大于x轴元素间距，则插入数据\n      if ( horizontalDragDistance > xAxisItemWidth) {\n        // 数据处理：根据上一刻的光标位置，判断鼠标拖动方向，更新数据重新渲染\n        if (lastPosition !== offsetX) {\n          console.log('拖拽中....');\n          // 往右拖动\n          if (lastPosition < offsetX) {\n            // 如果左侧数据全部显示完成，则不绘制\n            if (leftDataSource.length === 0) return\n\n            dataSource.unshift(leftDataSource.pop())\n            rightDataSource.unshift(dataSource.pop())\n          } else {\n            // 往左拖动\n            if (rightDataSource.length === 0) return\n\n            dataSource.push(rightDataSource.shift())\n            leftDataSource.push(dataSource.shift())\n          }\n        }\n\n        // 记录插入数据时的光标位置，用户判断下次的拖动方向\n        insertPosition = offsetX\n\n        // 清除画布并输入新数据重新绘制\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight)\n\n        // 触发重新渲染\n        renderCanvas()\n      }\n\n      lastPosition = offsetX\n    }, false);\n\n    // 拖动结束时，隐藏draggable，否则辅助线出不来\n    document.addEventListener(\"dragend\", function() {\n      console.log('-------拖拽结束');\n      const draggableNode = document.getElementById('draggable')\n      draggableNode.style.display = 'none'\n      draggableNode.style.cursor = 'default'\n\n      // 请求数据：如果左侧数据小于页数，请求接口数据\n      if (leftDataSource.length < maxShowSize) {\n        console.log('leftDataSource', leftDataSource);\n        console.log(`request: 左侧数据小于${maxShowSize}条，请求左侧数据，并赋值给myLeftDataSource.current`);\n\n        // 请求数据\n        loadData(maxShowSize, leftDataSource[0].date).then(res => {\n          leftDataSource = [...res, ...leftDataSource]\n        })\n      }\n    }, false);\n\n    // 鼠标按下时，显示拖拽元素在最上层\n    tipCanvas.addEventListener('mousedown', function (e) {\n      const kWrapNode = document.getElementById('canvasWrap')\n      const draggableNode = document.getElementById('draggable')\n\n      // 如果拖拽元素存在，则显示（避免重复创建）\n      if (draggableNode) {\n        draggableNode.style.display = 'block'\n        draggableNode.style.cursor = 'grab'\n        return\n      }\n\n      //创建拖拽元素\n      const div = document.createElement('div')\n      div.style.position = 'absolute'\n      div.style.zIndex = '10'\n      div.style.left = `${grid.left}px`\n      div.style.top = `${grid.top}px`\n      div.style.width = `${canvasWidth - grid.left - grid.right}px`\n      div.style.height = `${canvasHeight - grid.top - grid.bottom}px`\n      div.style.cursor = 'grab'\n      div.setAttribute('id', 'draggable')\n      div.setAttribute('draggable', 'true')\n\n      kWrapNode.appendChild(div)\n\n      // 处理“没有拖动时，单击拖拽元素后提示画布没有隐藏，表现为卡顿'的情况\n      // 解决：mouseup 时，隐蔽自己，否则拖拽元素在最上层，提示画布将被遮挡无法显示\n      // 因为拖拽元素在最上层，所以 mouseup 事件要绑定在拖拽元素上，绑在 tipCanvas 上无效\n      div.addEventListener('mouseup', function(e) {\n        div.style.display = 'none'\n      })\n    }, false)\n  }\n\n  // 缩放\n  const getScroll = () => {\n    const kWrapNode = document.getElementById('canvasWrap')\n    let timer = null\n\n    // 监听滚轮事件（只考虑chrome）\n    // 如需兼容火狐和ie，参考 https://blog.csdn.net/u014205965/article/details/46045099\n    kWrapNode.addEventListener('wheel', function(e) {\n      const { deltaX, deltaY } = e\n      console.log(Date.now());\n\n      // 方向判断\n      if (Math.abs(deltaX) !== 0 && Math.abs(deltaY) !== 0) return console.log('没有固定方向');\n      if (deltaX < 0) return console.log('向右');\n      if (deltaX > 0) return console.log('向左');\n\n      if (deltaY > 0) {\n        // console.log('向上、放大');\n        // 最小展示条数\n        if (dataSource.length <= pageSize) return\n\n        // 处理数据\n        leftDataSource.push(dataSource.shift())\n        rightDataSource.unshift(dataSource.pop())\n      };\n\n      if (deltaY < 0) {\n        // console.log('向下、缩小')\n        if (dataSource.length >= maxShowSize) return\n\n        dataSource = [leftDataSource.pop(), ...dataSource]\n      }\n\n      // 1. 先判断是否停止 2.停止后做什么\n      if (timer) {\n        clearTimeout(timer)\n      }\n      // 模拟缩放结束事件\n      const wheelStop = () => {\n        // 滚动停止时执行的代码\n        console.warn('wheelStop');\n        if (leftDataSource.length < maxShowSize) {\n          // 请求数据\n          loadData(maxShowSize, dataSource[0].date).then(res => {\n            leftDataSource = [...res, ...leftDataSource]\n          })\n        }\n      }\n      timer = setTimeout(wheelStop, 500);\n\n      ctx.clearRect(0, 0, canvasWidth, canvasHeight)\n      renderCanvas()\n    }, false)\n  }\n\n  /**\n   * 绘制画布\n   */\n   const renderCanvas = () => {\n    if (dataSource.length === 0) return\n\n    xAxisItemLength = dataSource.length\n    xAxisItemWidth = xAxisWidth / xAxisItemLength\n    const itemSpace = 3 // 表示x轴元素间距\n    candleWidth = (xAxisWidth - itemSpace * (xAxisItemLength - 1)) / xAxisItemLength\n\n    const maxPrice = Math.max(...dataSource.map(x => x.highestPrice)) + 5\n    const minPrice = Math.min(...dataSource.map(x => x.lowestPrice)) - 5\n\n    console.log('--------开始绘制k线图');\n\n    // 实际价格转为canvas纵坐标\n    const tranPriceToOrdinate = (price) => {\n      return yAxisOriginPointY - valueHeight(price, maxPrice, minPrice, yAxisHeight)\n    }\n\n    // 纵坐标集合\n    const dataYAxisPoint = dataSource.map(it => {\n      const newIt = {}\n      for (const key in it) {\n        if (key === 'date') continue\n        newIt[key] = tranPriceToOrdinate(it[key])\n      }\n      return newIt\n    })\n\n    // 绘制y轴文字和网格线\n    for (let i = 0; i < yAxisSplitNumber; i++) {\n      let sx = originalPointX\n      let ex = originalPointX + tickLength\n      let y = yAxisOriginPointY - yAxisTickSpace * i\n      // renderText(ctx, sx - candleWidth / 2 - 3, y, yAxisTickText(i*yAxisTickSpace, maxPrice, minPrice, yAxisHeight), 'right', TEXT_COLOR.PRIMARY)\n      renderLine(ctx, sx, y, xAxisVertexX, y, BORDER_COLOR.SECOND) // 网格线\n    }\n\n    // 绘制x轴\n    // renderLine(ctx, originalPointX, yAxisOriginPointY, xAxisVertexX, yAxisOriginPointY, BORDER_COLOR.SECOND)\n\n    // 绘制x轴刻度与文字\n    const remainder = Math.ceil(xAxisItemLength / (xAxisItemMaxShowNumber - 1))\n    for (let i = 0; i < xAxisItemLength; i++) {\n      const xAxisTickX = xAxisTickPointX(i, originalPointX, xAxisItemWidth)\n\n      // 隔点展示\n      // if (i % remainder === 0 || i === xAxisItemLength - 1) {\n      if (i % remainder === 0) {\n        renderText(ctx, xAxisTickX, yAxisOriginPointY + tickLength + 10, dataSource.map((x) => x.date)[i], 'center', TEXT_COLOR.PRIMARY)\n        renderLine(ctx, xAxisTickX, yAxisOriginPointY, xAxisTickX, yAxisOriginPointY + tickLength, BORDER_COLOR.SECOND) // 刻度线\n        renderLine(ctx, xAxisTickX, yAxisOriginPointY, xAxisTickX, yAxisVertexY, BORDER_COLOR.SECOND) // 网格线\n      }\n    }\n\n    /**\n     * 绘制贝塞尔曲线\n     * @param {array} controlPoint 控制点集合: [{ curX: lowestPricePointX, curY: lowestPricePointY, prevControlX, prevControlY, nextControlX, nextControlY } ...]\n     * @param {string}  color 曲线颜色\n     */\n    const renderBezierCurve = (controlPoint, color) => {\n      ctx.beginPath();\n      for (let i = 0; i < controlPoint.length; i++) {\n        const {\n          curX,\n          curY,\n          prevControlX,\n          prevControlY,\n        } = controlPoint[i]\n\n        if (i > 0 && i < controlPoint.length) {\n          const prevNode = controlPoint[i - 1]\n          ctx.bezierCurveTo(prevNode.nextControlX, prevNode.nextControlY, prevControlX, prevControlY, curX, curY);\n          ctx.strokeStyle = color\n          ctx.lineWidth = 0.7\n        } else if ( i === 0) {\n          ctx.moveTo(curX, curY);\n        }\n      }\n      ctx.stroke();\n    }\n\n    /**\n     * 求均线值在纵坐标中的值的集合。Moving average 移动平均线。MA = (C1+C2+C3+C4+C5+....+Cn)/n C 为收盘价，n 为移动平均周期数\n     * @param {number} day 前day天\n     * @returns array 纵坐标集合\n     */\n    const getMA = (day) => {\n      // const result = [];\n      const avgList = []\n      dataSource.map((it, i) => {\n        let beforeDays = [] // 前day日，开盘价集合\n        if (i < day) {\n          beforeDays = [...leftDataSource.slice(-day + i), ...dataSource.slice(0, i)];\n        } else {\n          beforeDays = [...dataSource.slice(i-day, i)]\n        }\n        const totalOpenPrice = beforeDays.reduce((prev, item) => prev + item.openingPrice, 0)\n        // result.push(tranPriceToOrdinate())\n        avgList.push(totalOpenPrice / day)\n\n        // 初始化时，当前日期的均线值\n        if (i === dataSource.length - 1) {\n          setMAList(MAList.set(day, { ...MAList.get(day), curVal: totalOpenPrice / day }))\n        }\n      })\n      setMAList(MAList.set(day, { ...MAList.get(day), list: avgList }))\n\n      return avgList.map(x => tranPriceToOrdinate(x));\n    }\n\n    /**\n     * 获取平均线控制点集合\n     * @param {number} day 前day天\n     * @returns [array] 当前点以及前后控制点坐集合\n     */\n    const getMAControlPointInfo = (day) => {\n      let controlPoint = []\n      const _MAList = getMA(day)\n\n      for (let i = 0; i < xAxisItemLength; i++) {\n        const pricePointX = xAxisTickPointX(i, originalPointX, xAxisItemWidth)\n        const pricePointY = _MAList[i]\n        let prevNode = 0  // 前控制的纵坐标\n        let nextNode = 0\n\n        // 边界处理：在首尾加入虚拟点，补全第一个元素没有前控制点，末尾元素没有后控制点的情况\n        if (i === 0) {\n          prevNode = pricePointY + 1\n          nextNode = _MAList[i + 1]\n        } else if (i === xAxisItemLength - 1) {\n          prevNode = _MAList[i - 1]\n          nextNode = pricePointY + 1\n        } else {\n          prevNode = _MAList[i - 1]\n          nextNode = _MAList[i + 1]\n        }\n        // 前后点构成的三角形\n        // b: 三角形的高\n        const triangleHeight = Math.abs(nextNode - prevNode)\n\n        // a: 三角形底边\n        const triangleBottomLine = xAxisItemWidth * 2\n        // c: 三角形斜边 = (高的平方+底边的平方)的平方根\n        const triangleHypotenuse = Math.sqrt(Math.pow(triangleHeight, 2) +  Math.pow(triangleBottomLine, 2))\n\n        // 前后控制点为斜边的三角形\n        // C: 控制点三角形斜边长度(自定义)\n        const controlPointW = xAxisItemWidth * 0.5\n        // A: 控制点三角形底边\n        const controlPointBottomLine = controlPointW * triangleBottomLine / triangleHypotenuse\n        // B: 控制点三角形的高\n        const controlPointHeight = controlPointW * triangleHeight / triangleHypotenuse\n\n        // 前一个控制点纵坐标\n        let prevControlY = undefined\n        // 后一个控制点纵坐标\n        let nextControlY = undefined\n\n        // 相对于canvas的坐标，如果前个控制点纵坐标小于下个控制点的纵坐标（相当于视觉上的左高右低）\n        if (prevNode < nextNode) {\n          // 左高右低\n          prevControlY = pricePointY - controlPointHeight / 2\n          nextControlY = pricePointY + controlPointHeight / 2\n        } else {\n          prevControlY = pricePointY + controlPointHeight / 2\n          nextControlY = pricePointY - controlPointHeight / 2\n        }\n\n        controlPoint.push({\n          curX: pricePointX,\n          curY: pricePointY,\n          prevControlX: pricePointX - controlPointBottomLine / 2,\n          prevControlY,\n          nextControlX: pricePointX + controlPointBottomLine / 2,\n          nextControlY\n        })\n      }\n\n      return controlPoint\n    }\n\n    // 绘制平均线\n    for (let [day, obj] of MAList)  {\n      renderBezierCurve(getMAControlPointInfo(day), obj)\n    }\n\n    if (init) {\n      oneByOneRenderCandle(dataYAxisPoint, candleWidth)\n      showTips && renderTipCanvas();\n      canDrag && getDrag();\n      canScroll && getScroll();\n    } else {\n      // 绘制一串蜡烛\n      renderCandles(dataYAxisPoint, candleWidth)\n    }\n\n    console.log('绘制完成');\n    init = false\n  }\n\n  // 得到上下文，开始初始化画布\n  useLayoutEffect(() => {\n    const canvasEl = document.getElementById('canvas');\n    const tipCanvasEl = document.getElementById('tipCanvas');\n    if (!canvasEl.getContext) {\n      console.error('该浏览器不支持展示<canvas>标签');\n      return;\n    }\n\n    ctx = canvasEl.getContext('2d')\n    const { width, height } = setCanvasSize(canvasEl, style, grid.width, grid.height)\n    setCanvasSize(tipCanvasEl, style, grid.width, grid.height)\n\n    // 可知条件\n    canvasWidth = width\n    canvasHeight = height\n    yAxisOriginPointY = height - grid.bottom\n    yAxisHeight = height - (grid.top + grid.bottom)\n    yAxisTickSpace = yAxisHeight / (yAxisSplitNumber - 1)\n    xAxisVertexX = width - grid.left\n    xAxisWidth = width - grid.left - grid.right\n    xAxisItemWidth = xAxisWidth / xAxisItemLength\n\n    // 请求数据\n    loadData(pageSize + maxShowSize).then(res => {\n      const data = res;\n      dataSource = data.slice(maxShowSize)\n      leftDataSource = data.slice(0, maxShowSize)\n      renderCanvas()\n    })\n  }, [])\n\n  console.log('-----------render--------------');\n  return (\n    <>\n      <div className=\"labels-container\">\n        <span className='abg-label'>均线</span>\n        {avgList.map(day => {\n          const { color, curVal } = MAList.get(day)\n          return <span key={`avg${day}`} style={{ color }} id={`avg${day}`}>{`MA${day} ${curVal}`}</span>\n        })}\n      </div>\n      <div id=\"canvasWrap\">\n        <canvas id=\"canvas\" style={{ backgroundColor }}></canvas>\n        <canvas id=\"tipCanvas\"></canvas>\n      </div>\n    </>\n  )\n}\nexport default React.memo(KLine)\n\n","import React, { useLayoutEffect } from 'react'\nimport { COLOR, TEXT_COLOR, BG_COLOR, BORDER_COLOR } from '../../colors/light';\nimport './index.css';\nimport { renderLine, renderText, yAxisTickText, xAxisTickPointX, valueHeight, setCanvasSize, renderRect, mergeObject, drawRoundedRect } from '../../utils/common';\n\nconst Bar = ({ option = {}, style = { width: '600px', height: '300px' } }) => {\n  // 默认配置项\n  const defaultConfig = {\n    yData: [],\n    xData: [],\n    // y轴分段数量\n    yAxisSplitNumber: 5,\n    // 背景色\n    backgroundColor: BG_COLOR.BODY,\n    // 对象放在...option后面做覆盖式更新\n    // 坐标轴与容器间的边距\n    grid: {\n      left: 30,\n      right: 30,\n      top: 30,\n      bottom: 30,\n      height: 'auto',\n      width: 'auto',\n    },\n    // 刻度相关\n    axisTick: {\n      length: 5,\n      show: true,\n    },\n  }\n  const config = mergeObject(defaultConfig, option)\n  const { yData, xData, yAxisSplitNumber, grid, axisTick: { length: tickLength, show: axisTickShow }, backgroundColor } = config;\n\n  // 初始变量\n  let canvasWidth = ''\n  let canvasHeight = ''\n  let yAxisHeight = ''  // y轴高度\n  let xAxisWidth = ''   // x轴宽度\n  let yAxisTickSpace = '' // y轴刻度间距\n  let originalPointY = '' // 原点纵坐标\n  let xAxisTopPointX = '' // x轴顶点横坐标\n  let yAxisOriginPointY = '' // y轴原点纵坐标\n  let xAxisItemLength = ''\n\n  // 初始常量\n  const originalPointX = grid.left  // 原点横坐标\n  const yAxisVertexY = grid.top // y轴顶点纵坐标\n\n  /**\n   * 绘制辅助线画布\n   */\n   const renderTipCanvas = () => {\n    console.log('绘制辅助线画布');\n    const tipCanvas = document.getElementById('tipCanvas');\n    const ctxTip = tipCanvas.getContext('2d');\n\n    // 提示框内部样式配置\n    const padding_horizontal = 10;\n    const padding_vertical = 25;\n\n    // 提示框元素宽度\n    let tipInfoElWidth = 100\n    // 提示框高度\n    let tipInfoElHeight = 50\n\n    // 判断鼠标是否在k线图内容区域\n    const isContentArea = (e) => {\n      const { offsetX, offsetY } = e\n      return  offsetX > originalPointX &&\n              offsetX < canvasWidth - grid.right &&\n              offsetY > grid.top &&\n              offsetY < yAxisOriginPointY\n    }\n\n    // 监听鼠标移动事件并绘制辅助线\n    tipCanvas.addEventListener('mousemove', function (e) {\n      // 鼠标距目标节点左上角的X坐标、Y坐标\n      const { offsetX, offsetY } = e\n      // 清除画布\n      ctxTip.clearRect(0, 0, canvasWidth, canvasHeight)\n      // 不在内容区域则不进行绘制\n      if (!isContentArea(e)) return\n\n      // 获取x轴元素在x轴上的下标和数据\n      const xTipIndex = Math.floor((offsetX - originalPointX) / xAxisWidth * xAxisItemLength)\n      const label = xData[xTipIndex]\n      const value = yData[xTipIndex]\n\n      const xAxisItemWidth = xAxisWidth / xAxisItemLength\n      const xAxisTickX = xAxisTickPointX(xTipIndex, originalPointX, xAxisItemWidth)\n\n      const dist =  10 // 提示框距离鼠标的距离\n      let tipInfoPointX = offsetX + dist  //  提示框的开始横坐标\n      if (offsetX >  (canvasWidth / 2 - grid.left)) {\n        tipInfoPointX = offsetX - tipInfoElWidth - dist\n      }\n\n      // 绘制矩形背景\n      ctxTip.beginPath()\n      ctxTip.moveTo(xAxisTickX, yAxisVertexY)\n      ctxTip.rect(xAxisTickX, yAxisVertexY, xAxisItemWidth, yAxisHeight)\n      ctxTip.fillStyle = COLOR.PRIMARY\n      ctxTip.globalAlpha = 0.1\n      ctxTip.shadowBlur = 0;\n      ctxTip.shadowOffsetX = 0\n      ctxTip.shadowOffsetY = 0\n      ctxTip.fill();\n      ctxTip.closePath();\n\n      // 绘制提示框\n      ctxTip.beginPath()\n      drawRoundedRect({\n        x: tipInfoPointX,\n        y: offsetY + 10,\n        width: tipInfoElWidth,\n        height: tipInfoElHeight\n      }, 5, ctxTip)\n      ctxTip.fillStyle = BG_COLOR.BODY\n      ctxTip.globalAlpha = 1\n      // 阴影\n      ctxTip.shadowColor = BORDER_COLOR.SECOND;\n      ctxTip.shadowBlur = 8;\n      ctxTip.shadowOffsetX = 1\n      ctxTip.shadowOffsetY = 1\n      ctxTip.fill();\n\n      // 绘制提示框内的元素\n      const y = offsetY + 10 + padding_vertical;\n      renderText(ctxTip, tipInfoPointX + padding_horizontal, y, label, 'left', TEXT_COLOR.PRIMARY, '13px')\n      renderText(ctxTip, tipInfoPointX + padding_horizontal * 6, y, value, 'left', TEXT_COLOR.PRIMARY, '14px')\n    }, false)\n  }\n\n  // 绘制画布\n  const renderCanvas = (ctx) => {\n    // 随画布元素数量变化而变化的属性\n    xAxisItemLength = xData.length;\n    // 最大最小值\n    const maxValue = Math.max(...yData) + 20\n    // const minValue = Math.min(...yData)\n    const minValue = 0\n    const xAxisItemWidth = xAxisWidth / xAxisItemLength\n    const itemSpace = 30 // 表示x轴元素间距\n    const barWidth = (xAxisWidth - itemSpace * (xAxisItemLength - 1)) / xAxisItemLength\n    const barMarginLeft = itemSpace / 2\n\n    // 绘制y轴文字与网格线\n    for (let i = 0; i < yAxisSplitNumber; i++) {\n      let y = originalPointY - yAxisTickSpace * i\n\n      // y轴文字\n      renderText(ctx, originalPointX - 10, y, yAxisTickText(i*yAxisTickSpace, maxValue, minValue, yAxisHeight, 0), 'right', TEXT_COLOR.PRIMARY)\n      // 水平网格线\n      renderLine(ctx, originalPointX, y, xAxisTopPointX, y, BORDER_COLOR.SECOND)\n    }\n\n    // 绘制x轴\n    const xAxisItemMaxShowNumber = 20;  // 最多展示xAxisItemMaxShowNumber个\n    const remainder = Math.ceil(xAxisItemLength / (xAxisItemMaxShowNumber - 1))\n    renderLine(ctx, originalPointX, originalPointY, xAxisTopPointX, originalPointY, COLOR.LINE)\n    // 绘制x轴刻度与文字\n    for (let i = 0; i < xAxisItemLength; i++) {\n      const xAxisTickX = xAxisTickPointX(i, originalPointX, xAxisItemWidth)\n\n      if (i % remainder === 0) {\n        renderText(ctx, xAxisTickX + xAxisItemWidth / 2, originalPointY + tickLength + 10, xData[i], 'center', TEXT_COLOR.PRIMARY)\n        axisTickShow && renderLine(ctx, xAxisTickX, originalPointY, xAxisTickX, originalPointY + tickLength, BORDER_COLOR.SECOND)\n      }\n    }\n\n    // 图形坐标点集合\n    const dataPoint = []\n    for (let i = 0; i < xAxisItemLength; i++) {\n      const value = yData[i];\n\n      const x = xAxisTickPointX(i, originalPointX, xAxisItemWidth) + barMarginLeft\n      const y = originalPointY - valueHeight(value, maxValue, minValue, yAxisHeight)\n      dataPoint.push({ x, y })\n    }\n\n    // 绘制矩形\n    for (let i = 0; i < xAxisItemLength; i++) {\n      const value = yData[i];\n      const { x, y } = dataPoint[i];\n      const h = valueHeight(value, maxValue, minValue, yAxisHeight)\n      ctx.beginPath()\n      drawRoundedRect({\n        x,\n        y,\n        width: barWidth,\n        height: h\n      }, 3, ctx)\n      ctx.fillStyle = COLOR.PRIMARY\n      ctx.globalAlpha = 0.9\n      ctx.fill();\n    }\n\n    renderTipCanvas()\n  }\n\n  // DOM 变更之后，渲染之前 执行\n  useLayoutEffect(() => {\n    const canvasEl = document.getElementById('canvas');\n    const tipCanvasEl = document.getElementById('tipCanvas');\n    if (!canvasEl.getContext) {\n      console.error('该浏览器不支持展示<canvas>标签');\n      return;\n    }\n\n    const ctx = canvasEl.getContext('2d')\n    const { width, height } = setCanvasSize(canvasEl, style, grid.width, grid.height)\n    setCanvasSize(tipCanvasEl, style, grid.width, grid.height)\n\n    // 可知条件：根据画布宽高计算\n    canvasWidth = width\n    canvasHeight = height\n    yAxisHeight = height - (grid.top + grid.bottom)\n    originalPointY = height - grid.bottom\n    yAxisTickSpace = yAxisHeight / (yAxisSplitNumber - 1)\n    xAxisTopPointX = width - grid.left\n    xAxisWidth = width - grid.left - grid.right\n    yAxisOriginPointY = height - grid.bottom\n\n    // 获取到数据后再填入数据和配置项\n    yData.length && renderCanvas(ctx)\n  }, [yData])\n\n  return (\n    <div id=\"canvasWrap\">\n      <canvas id=\"canvas\" style={{ backgroundColor }} />\n      <canvas id=\"tipCanvas\" />\n    </div>\n  )\n}\nexport default Bar;","import React, { useLayoutEffect } from 'react'\nimport { COLOR, TEXT_COLOR, BG_COLOR, BORDER_COLOR } from '../../colors/light';\nimport { renderLine, renderText, yAxisTickText, xAxisTickPointX, valueHeight, setCanvasSize, mergeObject } from '../../utils/common';\n\nconst Line = ({ option = {}, style = { width: '600px', height: '300px' } }) => {\n  // 默认配置项\n  const defaultConfig = {\n    yData: [],\n    xData: [],\n    // y轴分段数量\n    yAxisSplitNumber: 5,\n    // 背景色\n    backgroundColor: BG_COLOR.BODY,\n    // 对象放在...option后面做覆盖式更新\n    // 坐标轴与容器间的边距\n    grid: {\n      left: 30,\n      right: 30,\n      top: 30,\n      bottom: 30,\n      height: 'auto',\n      width: 'auto',\n    },\n    // 刻度相关\n    axisTick: {\n      length: 5,\n      show: true,\n    },\n  }\n  const config = mergeObject(defaultConfig, option)\n  const { yData, xData, yAxisSplitNumber, grid, axisTick: { length: axisTickLength, show: axisTickShow }, backgroundColor } = config;\n\n  // 初始变量\n  let yAxisHeight = ''  // y轴高度\n  let xAxisWidth = ''   // x轴宽度\n  let yAxisTickSpace = '' // y轴刻度间距\n  let originalPointY = '' // 原点纵坐标\n  let xAxisTopPointX = '' // x轴顶点横坐标\n\n  // 初始常量\n  const originalPointX = grid.left  // 原点横坐标\n\n  // 绘制画布\n  const renderCanvas = (ctx) => {\n    // 随画布元素数量变化而变化的属性\n    const xAxisItemLength = xData.length;\n    // x轴元素间距\n    const xAxisItemSpace = xAxisWidth / xAxisItemLength\n    // 让x轴（刻度和矩形）向右移动的偏移量\n    const xAxisItemSpaceHalf = xAxisItemSpace / 2\n    // 最大最小值\n    const maxValue = Math.max(...yData)\n    const minValue = Math.min(...yData)\n\n    // 绘制y轴文字与网格线\n    for (let i = 0; i < yAxisSplitNumber; i++) {\n      let y = originalPointY - yAxisTickSpace * i\n\n      // y轴文字\n      renderText(ctx, originalPointX - 10, y, yAxisTickText(i*yAxisTickSpace, maxValue, minValue, yAxisHeight, 0), 'right', TEXT_COLOR.PRIMARY)\n      // 网格线\n      renderLine(ctx, originalPointX, y, xAxisTopPointX, y, BORDER_COLOR.SECOND)\n    }\n\n    // 绘制x轴\n    renderLine(ctx, originalPointX, originalPointY, xAxisTopPointX, originalPointY, COLOR.LINE)\n    // 绘制x轴刻度与文字\n    for (let i = 0; i < xAxisItemLength; i++) {\n      const xAxisTickX = xAxisTickPointX(i, originalPointX, xAxisItemSpace)\n\n      renderText(ctx, xAxisTickX + xAxisItemSpaceHalf, originalPointY + axisTickLength + 10, xData[i], 'center', TEXT_COLOR.PRIMARY)\n      axisTickShow && renderLine(ctx, xAxisTickX, originalPointY, xAxisTickX, originalPointY + axisTickLength, BORDER_COLOR.SECOND)\n    }\n\n    // 折线坐标点集合\n    const dataPoint = []\n    for (let i = 0; i < xAxisItemLength; i++) {\n      const value = yData[i];\n\n      const x = xAxisTickPointX(i, originalPointX, xAxisItemSpace) + xAxisItemSpaceHalf\n      const y = originalPointY - valueHeight(value, maxValue, minValue, yAxisHeight)\n      dataPoint.push({ x, y })\n    }\n\n    // 绘制折线\n    for(let i = 0; i < dataPoint.length - 1; i++) {\n      const { x, y } = dataPoint[i];\n      const { x: nextX, y: nextY } = dataPoint[i+1];\n\n      renderLine(ctx, x, y, nextX, nextY, COLOR.PRIMARY, 1)\n\n      // 绘制拐点小圆形\n      ctx.beginPath();\n      ctx.arc(x, y, 1, 0, Math.PI * 2, true); // 绘制\n      ctx.fillStyle = COLOR.PRIMARY;\n      ctx.fill()\n\n      // 动画\n      // (function(j) {\n      //   setTimeout(() => {\n      //     const { x, y } = dataPoint[i];\n      //     const { x: nextX, y: nextY } = dataPoint[i+1];\n\n      //     renderLine(ctx, x, y, nextX, nextY, COLOR.PRIMARY, 1)\n\n      //     // 绘制拐点小圆形\n      //     ctx.beginPath();\n      //     ctx.arc(x, y, 1, 0, Math.PI * 2, true); // 绘制\n      //     ctx.fillStyle = COLOR.PRIMARY;\n      //     ctx.fill()\n      //   }, j * 100)\n      // }(i))\n    }\n  }\n\n  // DOM 变更之后，渲染之前 执行\n  useLayoutEffect(() => {\n    const canvasEl = document.getElementById('canvas')\n    const ctx = canvasEl.getContext('2d')\n\n    const { width, height } = setCanvasSize(canvasEl, style, grid.width, grid.height)\n\n    // 可知条件：根据画布宽高计算\n    yAxisHeight = height - (grid.top + grid.bottom)\n    originalPointY = height - grid.bottom\n    yAxisTickSpace = yAxisHeight / (yAxisSplitNumber - 1)\n    xAxisTopPointX = width - grid.left\n    xAxisWidth = width - grid.left - grid.right\n\n    // 获取到数据后再填入数据和配置项\n    yData.length && renderCanvas(ctx)\n  }, [yData])\n\n  return <canvas id=\"canvas\" style={{ backgroundColor }} />\n}\nexport default Line;"],"sourceRoot":""}