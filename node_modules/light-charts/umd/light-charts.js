/*!
 * light-charts v1.1.3 - https://weilun0510.github.io/light-charts-docs
 * MIT Licensed
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["ReactLoadingButton"] = factory(require("react"));
	else
		root["ReactLoadingButton"] = factory(root["React"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(4);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "Test", function() { return /* reexport */ Test_default; });
__webpack_require__.d(__webpack_exports__, "KLine", function() { return /* reexport */ src_exports_KLine; });
__webpack_require__.d(__webpack_exports__, "Bar", function() { return /* reexport */ src_exports_Bar; });
__webpack_require__.d(__webpack_exports__, "Line", function() { return /* reexport */ exports_Line; });

// EXTERNAL MODULE: external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react"}
var external_root_React_commonjs2_react_commonjs_react_amd_react_ = __webpack_require__(0);
var external_root_React_commonjs2_react_commonjs_react_amd_react_default = /*#__PURE__*/__webpack_require__.n(external_root_React_commonjs2_react_commonjs_react_amd_react_);

// CONCATENATED MODULE: ./src/exports/Test/index.js
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Test_default = /*#__PURE__*/function (_Component) {
  _inheritsLoose(_default, _Component);
  function _default() {
    return _Component.apply(this, arguments) || this;
  }
  var _proto = _default.prototype;
  _proto.render = function render() {
    return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement("div", null, /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement("h2", null, "Welcome to React components"));
  };
  return _default;
}(external_root_React_commonjs2_react_commonjs_react_amd_react_["Component"]);

// EXTERNAL MODULE: ./src/exports/KLine/index.css
var exports_KLine = __webpack_require__(2);

// CONCATENATED MODULE: ./src/colors/light.js
var light_COLOR = {
  PRIMARY: '#207BF7',
  RED: '#FF3333',
  GREEN: '#46B262',
  LINE: '#FDFDFD',
  TIP_LINE: '#727183',
  WHITE: '#FFF',
  BLACK: '#000'
};
var TEXT_COLOR = {
  PRIMARY: '#333',
  SECOND: '#666',
  RED: '#FF3333'
};
var BG_COLOR = {
  // 背景色：整体背景颜色
  BODY: '#FFFFFF',
  // 前景色：和整体背景色对比
  COMPONENT: '#F3F5FB'
};
var BORDER_COLOR = {
  PRIMARY: '#C5C5C5',
  SECOND: '#C9C9C9'
};
var LINE_COLOR = {
  YELLOW: '#FAB339',
  ORANGE: '#FF752A',
  BLUE: '#207BF7'
};

// CONCATENATED MODULE: ./src/utils/common.js
/**
 * 设置容器和画布宽高，并返回画布宽高
 * @param {object} canvasEl canvas元素
 * @param {object} style 容器样式「宽、高」
 * @param {string | number} gridWidth grid组件的宽度 auto | 0-1（百分比，1代表100%）
 * @param {string | number} gridHeight grid组件的高度 auto | 0-1
 * @returns object 宽高
 */
var setCanvasSize = function setCanvasSize(canvasEl, style, gridWidth, gridHeight) {
  if (gridWidth === void 0) {
    gridWidth = 'auto';
  }
  if (gridHeight === void 0) {
    gridHeight = 'auto';
  }
  var ctx = canvasEl.getContext('2d');
  var width = +style.width.slice(0, -2);
  var height = +style.height.slice(0, -2);

  // 设置css样式
  canvasEl.style.width = width + 'px';
  canvasEl.style.height = height + 'px';

  // 解决不同视网膜屏幕下「像素比不一致」，文字、样式的模糊问题
  // 获取像素比，对画布大小和上下文进行缩放
  var ratio = getPixelRatio(ctx);

  // 1.对画布大小「宽高」进行缩放
  canvasEl.width = width * ratio;
  canvasEl.height = height * ratio;

  // 2.对画布水平、垂直方向的单位进行缩放（注意：从某些方面说, scale() 缩放的不是画布，而是画布上 1 个单位的距离）
  ctx.scale(ratio, ratio);
  return {
    width: gridWidth === 'auto' ? width : width * gridWidth,
    height: gridHeight === 'auto' ? height : height * gridWidth
  };
};

/**
   * 绘制线条
   * @param {number} ctx 上下文
   * @param {number} sx 开始坐标点横坐标
   * @param {number} sy 开始坐标点纵坐标
   * @param {number} ex 结束坐标点横坐标
   * @param {number} ey 结束坐标点纵坐标
   * @param {string} lineColor 线条颜色
   * @param {number} lineWidth 线条宽度
   */
var renderLine = function renderLine(ctx, sx, sy, ex, ey, lineColor, lineWidth) {
  if (lineColor === void 0) {
    lineColor = COLOR.BLACK;
  }
  if (lineWidth === void 0) {
    lineWidth = 0.2;
  }
  ctx.beginPath();
  ctx.moveTo(sx, sy);
  ctx.lineTo(ex, ey);
  ctx.strokeStyle = lineColor;
  ctx.lineWidth = lineWidth;
  ctx.stroke();
  ctx.closePath();
};

/**
   * 绘制文字
   * @param {object} ctx 上下文
   * @param {number} x 横坐标
   * @param {number} y 纵坐标
   * @param {string} text 文本
   * @param {string} align 文本对齐方式
   * @param {string} color 文本颜色
   */
var renderText = function renderText(ctx, x, y, text, align, color, font) {
  if (align === void 0) {
    align = 'left';
  }
  if (color === void 0) {
    color = '#FFF';
  }
  if (font === void 0) {
    font = '12px';
  }
  ctx.fillStyle = color; // 文字颜色
  ctx.textBaseline = "middle";
  ctx.textAlign = align;
  ctx.font = font + " Arial"; // 大小、字体
  ctx.fillText(text, x, y); // 描绘实体文字
};

/**
 * 计算Y轴刻度对应的数值：根据最大最小值动态变化
 * @param {number} height y轴刻度的高度
 * @param {number} maxValue 最大值
 * @param {number} minValue 最小值
 * @param {number} yAxisHeight y轴高度
 * @param {number} fractionDigits 保留几位小数
 * @returns number 刻度对应的数值
 */
var yAxisTickText = function yAxisTickText(height, maxValue, minValue, yAxisHeight, fractionDigits) {
  if (fractionDigits === void 0) {
    fractionDigits = 2;
  }
  // value 与 y轴高度的比例
  var ratio = (maxValue - minValue) / yAxisHeight;
  var value = (minValue + height * ratio).toFixed(fractionDigits);
  return value;
};

/**
 * 求x轴刻度横坐标
 * @param {number} i 下标
 * @param {number} xAxisPointX x轴原点横坐标
 * @param {number} xAxisItemWidth x轴元素宽度
 * @returns number x轴刻度横坐标
 */
var xAxisTickPointX = function xAxisTickPointX(i, xAxisPointX, xAxisItemWidth) {
  return xAxisPointX + i * xAxisItemWidth;
};

/**
 * 求该值在y轴高度中的所占的高度值
 * @param {number} value 数值
 * @param {number} maxValue 最大值
 * @param {number} minValue 最小值
 * @param {number} yAxisHeight y轴高度
 * @returns number 该数值的对应高度
 */
var valueHeight = function valueHeight(value, maxValue, minValue, yAxisHeight) {
  // 每块钱占自定义坐标系的高度
  var rate = yAxisHeight / (maxValue - minValue);
  // 当前价格占自定义坐标系的高度
  var h = rate * (value - minValue);
  return h;
};

/**
   * 绘制矩形
   * @param {object} ctx 上下文
   * @param {number} x 横坐标
   * @param {number} y 纵坐标
   * @param {number} width 宽度
   * @param {number} height 高度
   * @param {string} color 颜色
   */
var renderRect = function renderRect(ctx, x, y, width, height, color) {
  if (width === void 0) {
    width = 20;
  }
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.rect(x, y, width, height);
  ctx.fillStyle = color;
  ctx.fill();
};

/**
 * 返回像素比
 * @param {object} context 渲染上下文
 * @returns number
 */
var getPixelRatio = function getPixelRatio(context) {
  var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
  return (window.devicePixelRatio || 1) / backingStore;
};

/**
 * 深度合并对象
 * @param {object} object 默认对象
 * @param {object} target 目标对象
 */
var mergeObject = function mergeObject(object, target) {
  if (object === void 0) {
    object = {};
  }
  if (target === void 0) {
    target = {};
  }
  var res = {};
  for (var key in object) {
    if (Object.prototype.toString.call(target[key]) === '[object Object]') {
      res[key] = mergeObject(object[key], target[key]);
    } else {
      res[key] = target[key] || object[key];
    }
  }
  return res;
};
var Point = function Point(x, y) {
  return {
    x: x,
    y: y
  };
};
/**
 * 绘制圆角矩形
 * @param {function} rect 矩形函数
 * @param {number} r 圆角半径
 * @param object ctx
 */
var drawRoundedRect = function drawRoundedRect(rect, r, ctx) {
  var ptA = Point(rect.x + r, rect.y);
  var ptB = Point(rect.x + rect.width, rect.y);
  var ptC = Point(rect.x + rect.width, rect.y + rect.height);
  var ptD = Point(rect.x, rect.y + rect.height);
  var ptE = Point(rect.x, rect.y);
  ctx.beginPath();
  ctx.moveTo(ptA.x, ptA.y);
  ctx.arcTo(ptB.x, ptB.y, ptC.x, ptC.y, r);
  ctx.arcTo(ptC.x, ptC.y, ptD.x, ptD.y, r);
  ctx.arcTo(ptD.x, ptD.y, ptE.x, ptE.y, r);
  ctx.arcTo(ptE.x, ptE.y, ptA.x, ptA.y, r);
  ctx.stroke();
};
// CONCATENATED MODULE: ./src/exports/KLine/index.js
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }




var KLine_KLine = function KLine(_ref) {
  var _ref$option = _ref.option,
    option = _ref$option === void 0 ? {} : _ref$option,
    loadData = _ref.loadData,
    _ref$style = _ref.style,
    style = _ref$style === void 0 ? {
      width: '600px',
      height: '300px'
    } : _ref$style;
  // 默认配置项
  var defaultConfig = {
    // 均线类型
    avgList: [5, 10, 20],
    // 是否绘制辅助线
    showTips: true,
    // 是否可以拖拽
    canDrag: true,
    // 是否可缩放
    canScroll: true,
    pageSize: 40,
    // 最多一页展示多少条数据（最多maxShowSize条）
    maxShowSize: 80,
    // 基础默认配置
    // y轴分段数量
    yAxisSplitNumber: 4,
    // 背景色
    backgroundColor: BG_COLOR.BODY,
    // x轴元素「文字和刻度」最大展示个数
    xAxisItemMaxShowNumber: 5,
    // 坐标轴与容器间的边距
    grid: {
      left: 30,
      right: 30,
      top: 20,
      bottom: 20,
      height: 'auto',
      width: 'auto'
    },
    // 刻度相关
    axisTick: {
      length: 5,
      show: true
    }
  };
  var config = mergeObject(defaultConfig, option);
  var yAxisSplitNumber = config.yAxisSplitNumber,
    grid = config.grid,
    tickLength = config.axisTick.length,
    avgList = config.avgList,
    showTips = config.showTips,
    canDrag = config.canDrag,
    canScroll = config.canScroll,
    pageSize = config.pageSize,
    maxShowSize = config.maxShowSize,
    backgroundColor = config.backgroundColor,
    xAxisItemMaxShowNumber = config.xAxisItemMaxShowNumber;
  var _useState = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_["useState"])(function () {
      var map = new Map([]);
      var colorMap = {
        5: LINE_COLOR.YELLOW,
        10: LINE_COLOR.ORANGE,
        20: LINE_COLOR.BLUE
      };
      avgList.forEach(function (day) {
        map.set(day, {
          color: colorMap[day],
          curVal: '',
          list: []
        });
      });
      return map;
    }),
    MAList = _useState[0],
    setMAList = _useState[1]; // 平均线集合)

  // 因为该函数只能执行一次，我们想要更新数据，又想要拿到上次的值，所以使用useRef
  // 如果能确保只执行一次，使用普通变量也可以，不能确保的话，使用useRef
  var dataSource = [];
  var leftDataSource = [];
  var rightDataSource = [];

  // 初始变量：因为使用了React.memo,所以该函数只会执行一次，那么这些变量可以放在函数内部
  // TODO: ctx 放在useRef里
  var ctx = '';
  var canvasWidth = '';
  var canvasHeight = '';
  var yAxisOriginPointY = ''; // y轴原点纵坐标
  var yAxisHeight = ''; // y轴高度
  var yAxisTickSpace = ''; // y轴刻度间距
  var xAxisVertexX = ''; // x轴顶点横坐标
  var xAxisWidth = ''; // x轴宽度
  var init = true;

  // 初始常量
  var originalPointX = grid.left; // 原点横坐标
  var yAxisVertexY = grid.top; // y轴顶点纵坐标

  // 随画布元素数量变化而变化的属性
  var xAxisItemWidth = ''; // // x轴元素宽度
  var xAxisItemLength = pageSize;
  var candleWidth = ''; // 蜡烛宽度

  /**
   * 绘制一串蜡烛（更新阶段）
   * @param {array} dataYAxisPoint 数据源
   * @param {number} candleWidth 蜡烛宽度
   */
  var renderCandles = function renderCandles(dataYAxisPoint, candleWidth) {
    for (var i = 0, candleLength = dataYAxisPoint.length; i < candleLength; i++) {
      renderCandle(dataYAxisPoint[i], xAxisTickPointX(i, originalPointX, xAxisItemWidth), candleWidth);
    }
  };

  /**
   * 逐个渲染一串蜡烛（首次加载阶段）
   */
  var oneByOneRenderCandle = function oneByOneRenderCandle(dataYAxisPoint, candleWidth) {
    for (var i = 0, candleLength = dataYAxisPoint.length; i < candleLength; i++) {
      (function (j) {
        setTimeout(function () {
          renderCandle(dataYAxisPoint[j], xAxisTickPointX(j, originalPointX, xAxisItemWidth), candleWidth);
        }, j * 100);
      })(i);
    }
  };

  /**
   * 绘制单个蜡烛
   * @param {number} dataItem 当前元素数据
   * @param {number} xAxisItemPointX 蜡烛横坐标
   * @param {number} candleWidth 蜡烛宽度
   */
  var renderCandle = function renderCandle(dataItem, xAxisItemPointX, candleWidth) {
    var candleWidthHalf = candleWidth / 2;
    var highestPrice = dataItem.highestPrice,
      lowestPrice = dataItem.lowestPrice,
      openingPrice = dataItem.openingPrice,
      closingPrice = dataItem.closingPrice;
    var secondPointY = undefined;
    var thirdPointY = undefined;
    var candleColor = undefined;
    if (closingPrice < openingPrice) {
      // 涨
      candleColor = light_COLOR.RED;
      secondPointY = closingPrice;
      thirdPointY = openingPrice;
    } else {
      candleColor = light_COLOR.GREEN;
      secondPointY = openingPrice;
      thirdPointY = closingPrice;
    }

    // 绘制蜡烛上影线
    renderLine(ctx, xAxisItemPointX, highestPrice, xAxisItemPointX, secondPointY, candleColor, 1);

    // 绘制蜡烛下影线
    renderLine(ctx, xAxisItemPointX, lowestPrice, xAxisItemPointX, thirdPointY, candleColor, 1);

    // 绘制蜡烛实体（绘制矩形）
    ctx.beginPath();
    ctx.moveTo(xAxisItemPointX - candleWidthHalf, secondPointY);
    ctx.rect(xAxisItemPointX - candleWidthHalf, secondPointY, candleWidth, thirdPointY - secondPointY);
    ctx.fillStyle = candleColor;
    if (candleColor === light_COLOR.RED) {
      ctx.stroke();
    } else {
      ctx.fill();
    }
  };

  /**
   * 绘制辅助线画布
   */
  var renderTipCanvas = function renderTipCanvas() {
    console.log('绘制辅助线画布');
    var tipCanvas = document.getElementById('tipCanvas');
    var ctxTip = tipCanvas.getContext('2d');
    var maxPrice = Math.max.apply(Math, dataSource.map(function (x) {
      return x.highestPrice;
    })) + 5;
    var minPrice = Math.min.apply(Math, dataSource.map(function (x) {
      return x.lowestPrice;
    })) - 5;

    // 提示框内部样式配置
    var padding_horizontal = 10;
    var padding_vertical = 20;
    var item_space = 20;

    // 提示框元素宽度
    var tipInfoElWidth = 100;
    // 提示框高度
    var tipInfoElHeight = 120;
    // x轴y轴上的提示背景框的宽、高
    var xyAxisTipBoxWidth = 50;
    var xyAxisTipBoxHeight = 20;

    // 判断鼠标是否在k线图内容区域
    var isContentArea = function isContentArea(e) {
      var offsetX = e.offsetX,
        offsetY = e.offsetY;
      return offsetX > originalPointX - candleWidth / 2 && offsetX < canvasWidth + candleWidth / 2 - grid.right - xAxisWidth / xAxisItemLength && offsetY > grid.top && offsetY < yAxisOriginPointY;
    };

    // 监听鼠标移动事件并绘制辅助线
    tipCanvas.addEventListener('mousemove', function (e) {
      // 鼠标距目标节点左上角的X坐标、Y坐标
      var offsetX = e.offsetX,
        offsetY = e.offsetY;
      // 清除画布
      ctxTip.clearRect(0, 0, canvasWidth, canvasHeight);
      // 不在内容区域则不进行绘制
      if (!isContentArea(e)) return;

      // 绘制水平辅助线
      ctxTip.beginPath();
      ctxTip.setLineDash([3, 3]); // 设置虚线样式
      ctxTip.moveTo(originalPointX, offsetY);
      ctxTip.lineTo(canvasWidth - grid.right - xAxisWidth / xAxisItemLength, offsetY);
      ctxTip.strokeStyle = BORDER_COLOR.SECOND;
      ctxTip.stroke();

      // 绘制垂直辅助线
      ctxTip.beginPath();
      ctxTip.setLineDash([3, 3]);
      ctxTip.moveTo(offsetX, grid.top);
      ctxTip.lineTo(offsetX, yAxisOriginPointY);
      ctxTip.strokeStyle = BORDER_COLOR.PRIMARY;
      ctxTip.stroke();

      // 绘制y轴tip文字背景框
      ctxTip.beginPath();
      ctxTip.rect(originalPointX, offsetY - xyAxisTipBoxHeight / 2, xyAxisTipBoxWidth, xyAxisTipBoxHeight);
      ctxTip.fillStyle = BORDER_COLOR.SECOND;
      ctxTip.fill();

      // 绘制y轴tip文字
      renderText(ctxTip, originalPointX + 25, offsetY, yAxisTickText(yAxisOriginPointY - offsetY, maxPrice, minPrice, yAxisHeight), 'center', light_COLOR.WHITE);

      // 绘制x轴tip文字背景框
      ctxTip.beginPath();
      ctxTip.rect(offsetX - xyAxisTipBoxWidth / 2, yAxisOriginPointY, xyAxisTipBoxWidth, xyAxisTipBoxHeight);
      ctxTip.fillStyle = BORDER_COLOR.SECOND;
      ctxTip.fill();

      // 绘制x轴tip文字
      // 获取x轴元素在x轴上的下标
      var xTipIndex = Math.round((offsetX - originalPointX) / xAxisWidth * xAxisItemLength);
      renderText(ctxTip, offsetX, yAxisOriginPointY + xyAxisTipBoxHeight / 2, dataSource.map(function (x) {
        return x.date;
      })[xTipIndex] || '', 'center', light_COLOR.WHITE);

      // 更新均线值
      for (var _iterator = _createForOfIteratorHelperLoose(MAList), _step; !(_step = _iterator()).done;) {
        var _step$value = _step.value,
          day = _step$value[0],
          obj = _step$value[1];
        var curVal = obj.list[xTipIndex];
        document.getElementById("avg" + day).innerText = "MA" + day + " " + curVal;
      }

      // 绘制提示框
      var dist = 10; // 提示框距离鼠标的距离
      var marginTop = yAxisVertexY + 30; // 提示框距离画布顶部的距离
      var tipInfoPointX = offsetX + dist; //  提示框的开始横坐标
      // TODO
      if (offsetX > canvasWidth / 2 - grid.left) {
        // if (xTipIndex > xAxisItemLength / 2) {
        tipInfoPointX = offsetX - tipInfoElWidth - dist;
      }
      ctxTip.beginPath();
      drawRoundedRect({
        x: tipInfoPointX,
        y: marginTop,
        width: tipInfoElWidth,
        height: tipInfoElHeight
      }, 10, ctxTip);
      ctxTip.fillStyle = BG_COLOR.COMPONENT;
      ctxTip.globalAlpha = 0.9;
      ctxTip.fill();
      var _dataSource$xTipIndex = dataSource[xTipIndex],
        date = _dataSource$xTipIndex.date,
        highestPrice = _dataSource$xTipIndex.highestPrice,
        lowestPrice = _dataSource$xTipIndex.lowestPrice,
        openingPrice = _dataSource$xTipIndex.openingPrice,
        closingPrice = _dataSource$xTipIndex.closingPrice;
      var dataArr = [{
        label: '开盘',
        value: openingPrice
      }, {
        label: '收盘',
        value: closingPrice
      }, {
        label: '最高',
        value: highestPrice
      }, {
        label: '最低',
        value: lowestPrice
      }];
      var cloneDataArr = [{
        label: '时间',
        value: date
      }].concat(dataArr);
      // 绘制提示框内的元素
      cloneDataArr.forEach(function (_ref2, i) {
        var label = _ref2.label,
          value = _ref2.value;
        var y = marginTop + padding_vertical + i * item_space;
        renderText(ctxTip, tipInfoPointX + padding_horizontal, y, label, 'left', TEXT_COLOR.PRIMARY, '13px');
        renderText(ctxTip, tipInfoPointX + tipInfoElWidth - padding_horizontal, y, value, 'right', i !== 0 ? TEXT_COLOR.PRIMARY : TEXT_COLOR.RED, '13px');
      });
    }, false);
  };

  // 拖拽
  var getDrag = function getDrag() {
    // 水平拖动距离
    var horizontalDragDistance = 0;
    // 插入数据时的光标位置
    var insertPosition = 0;
    // 光标的上一个位置，用于判断拖动方向
    var lastPosition = '';

    /* 开始拖动目标元素时触发dragstart事件 */
    document.addEventListener("dragstart", function (event) {
      // 清除提示画布
      var tipCanvas = document.getElementById('tipCanvas');
      var ctxTip = tipCanvas.getContext('2d');
      ctxTip.clearRect(0, 0, canvasWidth, canvasHeight);
      insertPosition = event.offsetX;
      lastPosition = event.offsetX;
    }, false);

    /* 拖动目标元素时触发drag事件 */
    document.addEventListener("drag", function (event) {
      var offsetX = event.offsetX;

      // TODO 不清楚小于0的场景,是被display: none的原因吗??
      if (offsetX < 0) return;

      // 计算水平拖动距离
      horizontalDragDistance = Math.abs(offsetX - insertPosition);
      var draggableNode = document.getElementById('draggable');
      draggableNode.style.cursor = 'grabbing';

      // 如果拖动距离大于x轴元素间距，则插入数据
      if (horizontalDragDistance > xAxisItemWidth) {
        // 数据处理：根据上一刻的光标位置，判断鼠标拖动方向，更新数据重新渲染
        if (lastPosition !== offsetX) {
          console.log('拖拽中....');
          // 往右拖动
          if (lastPosition < offsetX) {
            // 如果左侧数据全部显示完成，则不绘制
            if (leftDataSource.length === 0) return;
            dataSource.unshift(leftDataSource.pop());
            rightDataSource.unshift(dataSource.pop());
          } else {
            // 往左拖动
            if (rightDataSource.length === 0) return;
            dataSource.push(rightDataSource.shift());
            leftDataSource.push(dataSource.shift());
          }
        }

        // 记录插入数据时的光标位置，用户判断下次的拖动方向
        insertPosition = offsetX;

        // 清除画布并输入新数据重新绘制
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);

        // 触发重新渲染
        renderCanvas();
      }
      lastPosition = offsetX;
    }, false);

    // 拖动结束时，隐藏draggable，否则辅助线出不来
    document.addEventListener("dragend", function () {
      console.log('-------拖拽结束');
      var draggableNode = document.getElementById('draggable');
      draggableNode.style.display = 'none';
      draggableNode.style.cursor = 'default';

      // 请求数据：如果左侧数据小于页数，请求接口数据
      if (leftDataSource.length < maxShowSize) {
        console.log('leftDataSource', leftDataSource);
        console.log("request: \u5DE6\u4FA7\u6570\u636E\u5C0F\u4E8E" + maxShowSize + "\u6761\uFF0C\u8BF7\u6C42\u5DE6\u4FA7\u6570\u636E\uFF0C\u5E76\u8D4B\u503C\u7ED9myLeftDataSource.current");

        // 请求数据
        loadData(maxShowSize, leftDataSource[0].date).then(function (res) {
          leftDataSource = [].concat(res, leftDataSource);
        });
      }
    }, false);

    // 鼠标按下时，显示拖拽元素在最上层
    tipCanvas.addEventListener('mousedown', function (e) {
      var kWrapNode = document.getElementById('canvasWrap');
      var draggableNode = document.getElementById('draggable');

      // 如果拖拽元素存在，则显示（避免重复创建）
      if (draggableNode) {
        draggableNode.style.display = 'block';
        draggableNode.style.cursor = 'grab';
        return;
      }

      //创建拖拽元素
      var div = document.createElement('div');
      div.style.position = 'absolute';
      div.style.zIndex = '10';
      div.style.left = grid.left + "px";
      div.style.top = grid.top + "px";
      div.style.width = canvasWidth - grid.left - grid.right + "px";
      div.style.height = canvasHeight - grid.top - grid.bottom + "px";
      div.style.cursor = 'grab';
      div.setAttribute('id', 'draggable');
      div.setAttribute('draggable', 'true');
      kWrapNode.appendChild(div);

      // 处理“没有拖动时，单击拖拽元素后提示画布没有隐藏，表现为卡顿'的情况
      // 解决：mouseup 时，隐蔽自己，否则拖拽元素在最上层，提示画布将被遮挡无法显示
      // 因为拖拽元素在最上层，所以 mouseup 事件要绑定在拖拽元素上，绑在 tipCanvas 上无效
      div.addEventListener('mouseup', function (e) {
        div.style.display = 'none';
      });
    }, false);
  };

  // 缩放
  var getScroll = function getScroll() {
    var kWrapNode = document.getElementById('canvasWrap');
    var timer = null;

    // 监听滚轮事件（只考虑chrome）
    // 如需兼容火狐和ie，参考 https://blog.csdn.net/u014205965/article/details/46045099
    kWrapNode.addEventListener('wheel', function (e) {
      var deltaX = e.deltaX,
        deltaY = e.deltaY;
      console.log(Date.now());

      // 方向判断
      if (Math.abs(deltaX) !== 0 && Math.abs(deltaY) !== 0) return console.log('没有固定方向');
      if (deltaX < 0) return console.log('向右');
      if (deltaX > 0) return console.log('向左');
      if (deltaY > 0) {
        // console.log('向上、放大');
        // 最小展示条数
        if (dataSource.length <= pageSize) return;

        // 处理数据
        leftDataSource.push(dataSource.shift());
        rightDataSource.unshift(dataSource.pop());
      }
      ;
      if (deltaY < 0) {
        // console.log('向下、缩小')
        if (dataSource.length >= maxShowSize) return;
        dataSource = [leftDataSource.pop()].concat(dataSource);
      }

      // 1. 先判断是否停止 2.停止后做什么
      if (timer) {
        clearTimeout(timer);
      }
      // 模拟缩放结束事件
      var wheelStop = function wheelStop() {
        // 滚动停止时执行的代码
        console.warn('wheelStop');
        if (leftDataSource.length < maxShowSize) {
          // 请求数据
          loadData(maxShowSize, dataSource[0].date).then(function (res) {
            leftDataSource = [].concat(res, leftDataSource);
          });
        }
      };
      timer = setTimeout(wheelStop, 500);
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      renderCanvas();
    }, false);
  };

  /**
   * 绘制画布
   */
  var renderCanvas = function renderCanvas() {
    if (dataSource.length === 0) return;
    xAxisItemLength = dataSource.length;
    xAxisItemWidth = xAxisWidth / xAxisItemLength;
    var itemSpace = 3; // 表示x轴元素间距
    candleWidth = (xAxisWidth - itemSpace * (xAxisItemLength - 1)) / xAxisItemLength;
    var maxPrice = Math.max.apply(Math, dataSource.map(function (x) {
      return x.highestPrice;
    })) + 5;
    var minPrice = Math.min.apply(Math, dataSource.map(function (x) {
      return x.lowestPrice;
    })) - 5;
    console.log('--------开始绘制k线图');

    // 实际价格转为canvas纵坐标
    var tranPriceToOrdinate = function tranPriceToOrdinate(price) {
      return yAxisOriginPointY - valueHeight(price, maxPrice, minPrice, yAxisHeight);
    };

    // 纵坐标集合
    var dataYAxisPoint = dataSource.map(function (it) {
      var newIt = {};
      for (var key in it) {
        if (key === 'date') continue;
        newIt[key] = tranPriceToOrdinate(it[key]);
      }
      return newIt;
    });

    // 绘制y轴文字和网格线
    for (var i = 0; i < yAxisSplitNumber; i++) {
      var sx = originalPointX;
      var ex = originalPointX + tickLength;
      var y = yAxisOriginPointY - yAxisTickSpace * i;
      // renderText(ctx, sx - candleWidth / 2 - 3, y, yAxisTickText(i*yAxisTickSpace, maxPrice, minPrice, yAxisHeight), 'right', TEXT_COLOR.PRIMARY)
      renderLine(ctx, sx, y, xAxisVertexX, y, BORDER_COLOR.SECOND); // 网格线
    }

    // 绘制x轴
    // renderLine(ctx, originalPointX, yAxisOriginPointY, xAxisVertexX, yAxisOriginPointY, BORDER_COLOR.SECOND)

    // 绘制x轴刻度与文字
    var remainder = Math.ceil(xAxisItemLength / (xAxisItemMaxShowNumber - 1));
    for (var _i = 0; _i < xAxisItemLength; _i++) {
      var xAxisTickX = xAxisTickPointX(_i, originalPointX, xAxisItemWidth);

      // 隔点展示
      // if (i % remainder === 0 || i === xAxisItemLength - 1) {
      if (_i % remainder === 0) {
        renderText(ctx, xAxisTickX, yAxisOriginPointY + tickLength + 10, dataSource.map(function (x) {
          return x.date;
        })[_i], 'center', TEXT_COLOR.PRIMARY);
        renderLine(ctx, xAxisTickX, yAxisOriginPointY, xAxisTickX, yAxisOriginPointY + tickLength, BORDER_COLOR.SECOND); // 刻度线
        renderLine(ctx, xAxisTickX, yAxisOriginPointY, xAxisTickX, yAxisVertexY, BORDER_COLOR.SECOND); // 网格线
      }
    }

    /**
     * 绘制贝塞尔曲线
     * @param {array} controlPoint 控制点集合: [{ curX: lowestPricePointX, curY: lowestPricePointY, prevControlX, prevControlY, nextControlX, nextControlY } ...]
     * @param {string}  color 曲线颜色
     */
    var renderBezierCurve = function renderBezierCurve(controlPoint, color) {
      ctx.beginPath();
      for (var _i2 = 0; _i2 < controlPoint.length; _i2++) {
        var _controlPoint$_i = controlPoint[_i2],
          curX = _controlPoint$_i.curX,
          curY = _controlPoint$_i.curY,
          prevControlX = _controlPoint$_i.prevControlX,
          prevControlY = _controlPoint$_i.prevControlY;
        if (_i2 > 0 && _i2 < controlPoint.length) {
          var prevNode = controlPoint[_i2 - 1];
          ctx.bezierCurveTo(prevNode.nextControlX, prevNode.nextControlY, prevControlX, prevControlY, curX, curY);
          ctx.strokeStyle = color;
          ctx.lineWidth = 0.7;
        } else if (_i2 === 0) {
          ctx.moveTo(curX, curY);
        }
      }
      ctx.stroke();
    };

    /**
     * 求均线值在纵坐标中的值的集合。Moving average 移动平均线。MA = (C1+C2+C3+C4+C5+....+Cn)/n C 为收盘价，n 为移动平均周期数
     * @param {number} day 前day天
     * @returns array 纵坐标集合
     */
    var getMA = function getMA(day) {
      // const result = [];
      var avgList = [];
      dataSource.map(function (it, i) {
        var beforeDays = []; // 前day日，开盘价集合
        if (i < day) {
          beforeDays = [].concat(leftDataSource.slice(-day + i), dataSource.slice(0, i));
        } else {
          beforeDays = [].concat(dataSource.slice(i - day, i));
        }
        var totalOpenPrice = beforeDays.reduce(function (prev, item) {
          return prev + item.openingPrice;
        }, 0);
        // result.push(tranPriceToOrdinate())
        avgList.push(totalOpenPrice / day);

        // 初始化时，当前日期的均线值
        if (i === dataSource.length - 1) {
          setMAList(MAList.set(day, _extends({}, MAList.get(day), {
            curVal: totalOpenPrice / day
          })));
        }
      });
      setMAList(MAList.set(day, _extends({}, MAList.get(day), {
        list: avgList
      })));
      return avgList.map(function (x) {
        return tranPriceToOrdinate(x);
      });
    };

    /**
     * 获取平均线控制点集合
     * @param {number} day 前day天
     * @returns [array] 当前点以及前后控制点坐集合
     */
    var getMAControlPointInfo = function getMAControlPointInfo(day) {
      var controlPoint = [];
      var _MAList = getMA(day);
      for (var _i3 = 0; _i3 < xAxisItemLength; _i3++) {
        var pricePointX = xAxisTickPointX(_i3, originalPointX, xAxisItemWidth);
        var pricePointY = _MAList[_i3];
        var prevNode = 0; // 前控制的纵坐标
        var nextNode = 0;

        // 边界处理：在首尾加入虚拟点，补全第一个元素没有前控制点，末尾元素没有后控制点的情况
        if (_i3 === 0) {
          prevNode = pricePointY + 1;
          nextNode = _MAList[_i3 + 1];
        } else if (_i3 === xAxisItemLength - 1) {
          prevNode = _MAList[_i3 - 1];
          nextNode = pricePointY + 1;
        } else {
          prevNode = _MAList[_i3 - 1];
          nextNode = _MAList[_i3 + 1];
        }
        // 前后点构成的三角形
        // b: 三角形的高
        var triangleHeight = Math.abs(nextNode - prevNode);

        // a: 三角形底边
        var triangleBottomLine = xAxisItemWidth * 2;
        // c: 三角形斜边 = (高的平方+底边的平方)的平方根
        var triangleHypotenuse = Math.sqrt(Math.pow(triangleHeight, 2) + Math.pow(triangleBottomLine, 2));

        // 前后控制点为斜边的三角形
        // C: 控制点三角形斜边长度(自定义)
        var controlPointW = xAxisItemWidth * 0.5;
        // A: 控制点三角形底边
        var controlPointBottomLine = controlPointW * triangleBottomLine / triangleHypotenuse;
        // B: 控制点三角形的高
        var controlPointHeight = controlPointW * triangleHeight / triangleHypotenuse;

        // 前一个控制点纵坐标
        var prevControlY = undefined;
        // 后一个控制点纵坐标
        var nextControlY = undefined;

        // 相对于canvas的坐标，如果前个控制点纵坐标小于下个控制点的纵坐标（相当于视觉上的左高右低）
        if (prevNode < nextNode) {
          // 左高右低
          prevControlY = pricePointY - controlPointHeight / 2;
          nextControlY = pricePointY + controlPointHeight / 2;
        } else {
          prevControlY = pricePointY + controlPointHeight / 2;
          nextControlY = pricePointY - controlPointHeight / 2;
        }
        controlPoint.push({
          curX: pricePointX,
          curY: pricePointY,
          prevControlX: pricePointX - controlPointBottomLine / 2,
          prevControlY: prevControlY,
          nextControlX: pricePointX + controlPointBottomLine / 2,
          nextControlY: nextControlY
        });
      }
      return controlPoint;
    };

    // 绘制平均线
    for (var _iterator2 = _createForOfIteratorHelperLoose(MAList), _step2; !(_step2 = _iterator2()).done;) {
      var _step2$value = _step2.value,
        day = _step2$value[0],
        obj = _step2$value[1];
      renderBezierCurve(getMAControlPointInfo(day), obj);
    }
    if (init) {
      oneByOneRenderCandle(dataYAxisPoint, candleWidth);
      showTips && renderTipCanvas();
      canDrag && getDrag();
      canScroll && getScroll();
    } else {
      // 绘制一串蜡烛
      renderCandles(dataYAxisPoint, candleWidth);
    }
    console.log('绘制完成');
    init = false;
  };

  // 得到上下文，开始初始化画布
  Object(external_root_React_commonjs2_react_commonjs_react_amd_react_["useLayoutEffect"])(function () {
    var canvasEl = document.getElementById('canvas');
    var tipCanvasEl = document.getElementById('tipCanvas');
    if (!canvasEl.getContext) {
      console.error('该浏览器不支持展示<canvas>标签');
      return;
    }
    ctx = canvasEl.getContext('2d');
    var _setCanvasSize = setCanvasSize(canvasEl, style, grid.width, grid.height),
      width = _setCanvasSize.width,
      height = _setCanvasSize.height;
    setCanvasSize(tipCanvasEl, style, grid.width, grid.height);

    // 可知条件
    canvasWidth = width;
    canvasHeight = height;
    yAxisOriginPointY = height - grid.bottom;
    yAxisHeight = height - (grid.top + grid.bottom);
    yAxisTickSpace = yAxisHeight / (yAxisSplitNumber - 1);
    xAxisVertexX = width - grid.left;
    xAxisWidth = width - grid.left - grid.right;
    xAxisItemWidth = xAxisWidth / xAxisItemLength;

    // 请求数据
    loadData(pageSize + maxShowSize).then(function (res) {
      var data = res;
      dataSource = data.slice(maxShowSize);
      leftDataSource = data.slice(0, maxShowSize);
      renderCanvas();
    });
  }, []);
  console.log('-----------render--------------');
  return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement(external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.Fragment, null, /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement("div", {
    className: "labels-container"
  }, /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement("span", {
    className: "abg-label"
  }, "\u5747\u7EBF"), avgList.map(function (day) {
    var _MAList$get = MAList.get(day),
      color = _MAList$get.color,
      curVal = _MAList$get.curVal;
    return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement("span", {
      key: "avg" + day,
      style: {
        color: color
      },
      id: "avg" + day
    }, "MA" + day + " " + curVal);
  })), /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement("div", {
    id: "canvasWrap"
  }, /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement("canvas", {
    id: "canvas",
    style: {
      backgroundColor: backgroundColor
    }
  }), /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement("canvas", {
    id: "tipCanvas"
  })));
};
/* harmony default export */ var src_exports_KLine = (external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.memo(KLine_KLine));
// EXTERNAL MODULE: ./src/exports/Bar/index.css
var exports_Bar = __webpack_require__(3);

// CONCATENATED MODULE: ./src/exports/Bar/index.js




var Bar_Bar = function Bar(_ref) {
  var _ref$option = _ref.option,
    option = _ref$option === void 0 ? {} : _ref$option,
    _ref$style = _ref.style,
    style = _ref$style === void 0 ? {
      width: '600px',
      height: '300px'
    } : _ref$style;
  // 默认配置项
  var defaultConfig = {
    yData: [],
    xData: [],
    // y轴分段数量
    yAxisSplitNumber: 5,
    // 背景色
    backgroundColor: BG_COLOR.BODY,
    // 对象放在...option后面做覆盖式更新
    // 坐标轴与容器间的边距
    grid: {
      left: 30,
      right: 30,
      top: 30,
      bottom: 30,
      height: 'auto',
      width: 'auto'
    },
    // 刻度相关
    axisTick: {
      length: 5,
      show: true
    }
  };
  var config = mergeObject(defaultConfig, option);
  var yData = config.yData,
    xData = config.xData,
    yAxisSplitNumber = config.yAxisSplitNumber,
    grid = config.grid,
    _config$axisTick = config.axisTick,
    tickLength = _config$axisTick.length,
    axisTickShow = _config$axisTick.show,
    backgroundColor = config.backgroundColor;

  // 初始变量
  var canvasWidth = '';
  var canvasHeight = '';
  var yAxisHeight = ''; // y轴高度
  var xAxisWidth = ''; // x轴宽度
  var yAxisTickSpace = ''; // y轴刻度间距
  var originalPointY = ''; // 原点纵坐标
  var xAxisTopPointX = ''; // x轴顶点横坐标
  var yAxisOriginPointY = ''; // y轴原点纵坐标
  var xAxisItemLength = '';

  // 初始常量
  var originalPointX = grid.left; // 原点横坐标
  var yAxisVertexY = grid.top; // y轴顶点纵坐标

  /**
   * 绘制辅助线画布
   */
  var renderTipCanvas = function renderTipCanvas() {
    console.log('绘制辅助线画布');
    var tipCanvas = document.getElementById('tipCanvas');
    var ctxTip = tipCanvas.getContext('2d');

    // 提示框内部样式配置
    var padding_horizontal = 10;
    var padding_vertical = 25;

    // 提示框元素宽度
    var tipInfoElWidth = 100;
    // 提示框高度
    var tipInfoElHeight = 50;

    // 判断鼠标是否在k线图内容区域
    var isContentArea = function isContentArea(e) {
      var offsetX = e.offsetX,
        offsetY = e.offsetY;
      return offsetX > originalPointX && offsetX < canvasWidth - grid.right && offsetY > grid.top && offsetY < yAxisOriginPointY;
    };

    // 监听鼠标移动事件并绘制辅助线
    tipCanvas.addEventListener('mousemove', function (e) {
      // 鼠标距目标节点左上角的X坐标、Y坐标
      var offsetX = e.offsetX,
        offsetY = e.offsetY;
      // 清除画布
      ctxTip.clearRect(0, 0, canvasWidth, canvasHeight);
      // 不在内容区域则不进行绘制
      if (!isContentArea(e)) return;

      // 获取x轴元素在x轴上的下标和数据
      var xTipIndex = Math.floor((offsetX - originalPointX) / xAxisWidth * xAxisItemLength);
      var label = xData[xTipIndex];
      var value = yData[xTipIndex];
      var xAxisItemWidth = xAxisWidth / xAxisItemLength;
      var xAxisTickX = xAxisTickPointX(xTipIndex, originalPointX, xAxisItemWidth);
      var dist = 10; // 提示框距离鼠标的距离
      var tipInfoPointX = offsetX + dist; //  提示框的开始横坐标
      if (offsetX > canvasWidth / 2 - grid.left) {
        tipInfoPointX = offsetX - tipInfoElWidth - dist;
      }

      // 绘制矩形背景
      ctxTip.beginPath();
      ctxTip.moveTo(xAxisTickX, yAxisVertexY);
      ctxTip.rect(xAxisTickX, yAxisVertexY, xAxisItemWidth, yAxisHeight);
      ctxTip.fillStyle = light_COLOR.PRIMARY;
      ctxTip.globalAlpha = 0.1;
      ctxTip.shadowBlur = 0;
      ctxTip.shadowOffsetX = 0;
      ctxTip.shadowOffsetY = 0;
      ctxTip.fill();
      ctxTip.closePath();

      // 绘制提示框
      ctxTip.beginPath();
      drawRoundedRect({
        x: tipInfoPointX,
        y: offsetY + 10,
        width: tipInfoElWidth,
        height: tipInfoElHeight
      }, 5, ctxTip);
      ctxTip.fillStyle = BG_COLOR.BODY;
      ctxTip.globalAlpha = 1;
      // 阴影
      ctxTip.shadowColor = BORDER_COLOR.SECOND;
      ctxTip.shadowBlur = 8;
      ctxTip.shadowOffsetX = 1;
      ctxTip.shadowOffsetY = 1;
      ctxTip.fill();

      // 绘制提示框内的元素
      var y = offsetY + 10 + padding_vertical;
      renderText(ctxTip, tipInfoPointX + padding_horizontal, y, label, 'left', TEXT_COLOR.PRIMARY, '13px');
      renderText(ctxTip, tipInfoPointX + padding_horizontal * 6, y, value, 'left', TEXT_COLOR.PRIMARY, '14px');
    }, false);
  };

  // 绘制画布
  var renderCanvas = function renderCanvas(ctx) {
    // 随画布元素数量变化而变化的属性
    xAxisItemLength = xData.length;
    // 最大最小值
    var maxValue = Math.max.apply(Math, yData) + 20;
    // const minValue = Math.min(...yData)
    var minValue = 0;
    var xAxisItemWidth = xAxisWidth / xAxisItemLength;
    var itemSpace = 30; // 表示x轴元素间距
    var barWidth = (xAxisWidth - itemSpace * (xAxisItemLength - 1)) / xAxisItemLength;
    var barMarginLeft = itemSpace / 2;

    // 绘制y轴文字与网格线
    for (var i = 0; i < yAxisSplitNumber; i++) {
      var y = originalPointY - yAxisTickSpace * i;

      // y轴文字
      renderText(ctx, originalPointX - 10, y, yAxisTickText(i * yAxisTickSpace, maxValue, minValue, yAxisHeight, 0), 'right', TEXT_COLOR.PRIMARY);
      // 水平网格线
      renderLine(ctx, originalPointX, y, xAxisTopPointX, y, BORDER_COLOR.SECOND);
    }

    // 绘制x轴
    var xAxisItemMaxShowNumber = 20; // 最多展示xAxisItemMaxShowNumber个
    var remainder = Math.ceil(xAxisItemLength / (xAxisItemMaxShowNumber - 1));
    renderLine(ctx, originalPointX, originalPointY, xAxisTopPointX, originalPointY, light_COLOR.LINE);
    // 绘制x轴刻度与文字
    for (var _i = 0; _i < xAxisItemLength; _i++) {
      var xAxisTickX = xAxisTickPointX(_i, originalPointX, xAxisItemWidth);
      if (_i % remainder === 0) {
        renderText(ctx, xAxisTickX + xAxisItemWidth / 2, originalPointY + tickLength + 10, xData[_i], 'center', TEXT_COLOR.PRIMARY);
        axisTickShow && renderLine(ctx, xAxisTickX, originalPointY, xAxisTickX, originalPointY + tickLength, BORDER_COLOR.SECOND);
      }
    }

    // 图形坐标点集合
    var dataPoint = [];
    for (var _i2 = 0; _i2 < xAxisItemLength; _i2++) {
      var value = yData[_i2];
      var x = xAxisTickPointX(_i2, originalPointX, xAxisItemWidth) + barMarginLeft;
      var _y = originalPointY - valueHeight(value, maxValue, minValue, yAxisHeight);
      dataPoint.push({
        x: x,
        y: _y
      });
    }

    // 绘制矩形
    for (var _i3 = 0; _i3 < xAxisItemLength; _i3++) {
      var _value = yData[_i3];
      var _dataPoint$_i = dataPoint[_i3],
        _x = _dataPoint$_i.x,
        _y2 = _dataPoint$_i.y;
      var h = valueHeight(_value, maxValue, minValue, yAxisHeight);
      ctx.beginPath();
      drawRoundedRect({
        x: _x,
        y: _y2,
        width: barWidth,
        height: h
      }, 3, ctx);
      ctx.fillStyle = light_COLOR.PRIMARY;
      ctx.globalAlpha = 0.9;
      ctx.fill();
    }
    renderTipCanvas();
  };

  // DOM 变更之后，渲染之前 执行
  Object(external_root_React_commonjs2_react_commonjs_react_amd_react_["useLayoutEffect"])(function () {
    var canvasEl = document.getElementById('canvas');
    var tipCanvasEl = document.getElementById('tipCanvas');
    if (!canvasEl.getContext) {
      console.error('该浏览器不支持展示<canvas>标签');
      return;
    }
    var ctx = canvasEl.getContext('2d');
    var _setCanvasSize = setCanvasSize(canvasEl, style, grid.width, grid.height),
      width = _setCanvasSize.width,
      height = _setCanvasSize.height;
    setCanvasSize(tipCanvasEl, style, grid.width, grid.height);

    // 可知条件：根据画布宽高计算
    canvasWidth = width;
    canvasHeight = height;
    yAxisHeight = height - (grid.top + grid.bottom);
    originalPointY = height - grid.bottom;
    yAxisTickSpace = yAxisHeight / (yAxisSplitNumber - 1);
    xAxisTopPointX = width - grid.left;
    xAxisWidth = width - grid.left - grid.right;
    yAxisOriginPointY = height - grid.bottom;

    // 获取到数据后再填入数据和配置项
    yData.length && renderCanvas(ctx);
  }, [yData]);
  return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement("div", {
    id: "canvasWrap"
  }, /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement("canvas", {
    id: "canvas",
    style: {
      backgroundColor: backgroundColor
    }
  }), /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement("canvas", {
    id: "tipCanvas"
  }));
};
/* harmony default export */ var src_exports_Bar = (Bar_Bar);
// CONCATENATED MODULE: ./src/exports/Line/index.js



var Line_Line = function Line(_ref) {
  var _ref$option = _ref.option,
    option = _ref$option === void 0 ? {} : _ref$option,
    _ref$style = _ref.style,
    style = _ref$style === void 0 ? {
      width: '600px',
      height: '300px'
    } : _ref$style;
  // 默认配置项
  var defaultConfig = {
    yData: [],
    xData: [],
    // y轴分段数量
    yAxisSplitNumber: 5,
    // 背景色
    backgroundColor: BG_COLOR.BODY,
    // 对象放在...option后面做覆盖式更新
    // 坐标轴与容器间的边距
    grid: {
      left: 30,
      right: 30,
      top: 30,
      bottom: 30,
      height: 'auto',
      width: 'auto'
    },
    // 刻度相关
    axisTick: {
      length: 5,
      show: true
    }
  };
  var config = mergeObject(defaultConfig, option);
  var yData = config.yData,
    xData = config.xData,
    yAxisSplitNumber = config.yAxisSplitNumber,
    grid = config.grid,
    _config$axisTick = config.axisTick,
    axisTickLength = _config$axisTick.length,
    axisTickShow = _config$axisTick.show,
    backgroundColor = config.backgroundColor;

  // 初始变量
  var yAxisHeight = ''; // y轴高度
  var xAxisWidth = ''; // x轴宽度
  var yAxisTickSpace = ''; // y轴刻度间距
  var originalPointY = ''; // 原点纵坐标
  var xAxisTopPointX = ''; // x轴顶点横坐标

  // 初始常量
  var originalPointX = grid.left; // 原点横坐标

  // 绘制画布
  var renderCanvas = function renderCanvas(ctx) {
    // 随画布元素数量变化而变化的属性
    var xAxisItemLength = xData.length;
    // x轴元素间距
    var xAxisItemSpace = xAxisWidth / xAxisItemLength;
    // 让x轴（刻度和矩形）向右移动的偏移量
    var xAxisItemSpaceHalf = xAxisItemSpace / 2;
    // 最大最小值
    var maxValue = Math.max.apply(Math, yData);
    var minValue = Math.min.apply(Math, yData);

    // 绘制y轴文字与网格线
    for (var i = 0; i < yAxisSplitNumber; i++) {
      var y = originalPointY - yAxisTickSpace * i;

      // y轴文字
      renderText(ctx, originalPointX - 10, y, yAxisTickText(i * yAxisTickSpace, maxValue, minValue, yAxisHeight, 0), 'right', TEXT_COLOR.PRIMARY);
      // 网格线
      renderLine(ctx, originalPointX, y, xAxisTopPointX, y, BORDER_COLOR.SECOND);
    }

    // 绘制x轴
    renderLine(ctx, originalPointX, originalPointY, xAxisTopPointX, originalPointY, light_COLOR.LINE);
    // 绘制x轴刻度与文字
    for (var _i = 0; _i < xAxisItemLength; _i++) {
      var xAxisTickX = xAxisTickPointX(_i, originalPointX, xAxisItemSpace);
      renderText(ctx, xAxisTickX + xAxisItemSpaceHalf, originalPointY + axisTickLength + 10, xData[_i], 'center', TEXT_COLOR.PRIMARY);
      axisTickShow && renderLine(ctx, xAxisTickX, originalPointY, xAxisTickX, originalPointY + axisTickLength, BORDER_COLOR.SECOND);
    }

    // 折线坐标点集合
    var dataPoint = [];
    for (var _i2 = 0; _i2 < xAxisItemLength; _i2++) {
      var value = yData[_i2];
      var x = xAxisTickPointX(_i2, originalPointX, xAxisItemSpace) + xAxisItemSpaceHalf;
      var _y = originalPointY - valueHeight(value, maxValue, minValue, yAxisHeight);
      dataPoint.push({
        x: x,
        y: _y
      });
    }

    // 绘制折线
    for (var _i3 = 0; _i3 < dataPoint.length - 1; _i3++) {
      var _dataPoint$_i = dataPoint[_i3],
        _x = _dataPoint$_i.x,
        _y2 = _dataPoint$_i.y;
      var _dataPoint = dataPoint[_i3 + 1],
        nextX = _dataPoint.x,
        nextY = _dataPoint.y;
      renderLine(ctx, _x, _y2, nextX, nextY, light_COLOR.PRIMARY, 1);

      // 绘制拐点小圆形
      ctx.beginPath();
      ctx.arc(_x, _y2, 1, 0, Math.PI * 2, true); // 绘制
      ctx.fillStyle = light_COLOR.PRIMARY;
      ctx.fill();

      // 动画
      // (function(j) {
      //   setTimeout(() => {
      //     const { x, y } = dataPoint[i];
      //     const { x: nextX, y: nextY } = dataPoint[i+1];

      //     renderLine(ctx, x, y, nextX, nextY, COLOR.PRIMARY, 1)

      //     // 绘制拐点小圆形
      //     ctx.beginPath();
      //     ctx.arc(x, y, 1, 0, Math.PI * 2, true); // 绘制
      //     ctx.fillStyle = COLOR.PRIMARY;
      //     ctx.fill()
      //   }, j * 100)
      // }(i))
    }
  };

  // DOM 变更之后，渲染之前 执行
  Object(external_root_React_commonjs2_react_commonjs_react_amd_react_["useLayoutEffect"])(function () {
    var canvasEl = document.getElementById('canvas');
    var ctx = canvasEl.getContext('2d');
    var _setCanvasSize = setCanvasSize(canvasEl, style, grid.width, grid.height),
      width = _setCanvasSize.width,
      height = _setCanvasSize.height;

    // 可知条件：根据画布宽高计算
    yAxisHeight = height - (grid.top + grid.bottom);
    originalPointY = height - grid.bottom;
    yAxisTickSpace = yAxisHeight / (yAxisSplitNumber - 1);
    xAxisTopPointX = width - grid.left;
    xAxisWidth = width - grid.left - grid.right;

    // 获取到数据后再填入数据和配置项
    yData.length && renderCanvas(ctx);
  }, [yData]);
  return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement("canvas", {
    id: "canvas",
    style: {
      backgroundColor: backgroundColor
    }
  });
};
/* harmony default export */ var exports_Line = (Line_Line);
// CONCATENATED MODULE: ./src/exports/index.js





// CONCATENATED MODULE: ./src/index.js



/***/ })
/******/ ])["default"];
});