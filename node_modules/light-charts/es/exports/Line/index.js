import React, { useLayoutEffect } from 'react';
import { COLOR, TEXT_COLOR, BG_COLOR, BORDER_COLOR } from '../../colors/light';
import { renderLine, renderText, yAxisTickText, xAxisTickPointX, valueHeight, setCanvasSize, mergeObject } from '../../utils/common';
var Line = function Line(_ref) {
  var _ref$option = _ref.option,
    option = _ref$option === void 0 ? {} : _ref$option,
    _ref$style = _ref.style,
    style = _ref$style === void 0 ? {
      width: '600px',
      height: '300px'
    } : _ref$style;
  // 默认配置项
  var defaultConfig = {
    yData: [],
    xData: [],
    // y轴分段数量
    yAxisSplitNumber: 5,
    // 背景色
    backgroundColor: BG_COLOR.BODY,
    // 对象放在...option后面做覆盖式更新
    // 坐标轴与容器间的边距
    grid: {
      left: 30,
      right: 30,
      top: 30,
      bottom: 30,
      height: 'auto',
      width: 'auto'
    },
    // 刻度相关
    axisTick: {
      length: 5,
      show: true
    }
  };
  var config = mergeObject(defaultConfig, option);
  var yData = config.yData,
    xData = config.xData,
    yAxisSplitNumber = config.yAxisSplitNumber,
    grid = config.grid,
    _config$axisTick = config.axisTick,
    axisTickLength = _config$axisTick.length,
    axisTickShow = _config$axisTick.show,
    backgroundColor = config.backgroundColor;

  // 初始变量
  var yAxisHeight = ''; // y轴高度
  var xAxisWidth = ''; // x轴宽度
  var yAxisTickSpace = ''; // y轴刻度间距
  var originalPointY = ''; // 原点纵坐标
  var xAxisTopPointX = ''; // x轴顶点横坐标

  // 初始常量
  var originalPointX = grid.left; // 原点横坐标

  // 绘制画布
  var renderCanvas = function renderCanvas(ctx) {
    // 随画布元素数量变化而变化的属性
    var xAxisItemLength = xData.length;
    // x轴元素间距
    var xAxisItemSpace = xAxisWidth / xAxisItemLength;
    // 让x轴（刻度和矩形）向右移动的偏移量
    var xAxisItemSpaceHalf = xAxisItemSpace / 2;
    // 最大最小值
    var maxValue = Math.max.apply(Math, yData);
    var minValue = Math.min.apply(Math, yData);

    // 绘制y轴文字与网格线
    for (var i = 0; i < yAxisSplitNumber; i++) {
      var y = originalPointY - yAxisTickSpace * i;

      // y轴文字
      renderText(ctx, originalPointX - 10, y, yAxisTickText(i * yAxisTickSpace, maxValue, minValue, yAxisHeight, 0), 'right', TEXT_COLOR.PRIMARY);
      // 网格线
      renderLine(ctx, originalPointX, y, xAxisTopPointX, y, BORDER_COLOR.SECOND);
    }

    // 绘制x轴
    renderLine(ctx, originalPointX, originalPointY, xAxisTopPointX, originalPointY, COLOR.LINE);
    // 绘制x轴刻度与文字
    for (var _i = 0; _i < xAxisItemLength; _i++) {
      var xAxisTickX = xAxisTickPointX(_i, originalPointX, xAxisItemSpace);
      renderText(ctx, xAxisTickX + xAxisItemSpaceHalf, originalPointY + axisTickLength + 10, xData[_i], 'center', TEXT_COLOR.PRIMARY);
      axisTickShow && renderLine(ctx, xAxisTickX, originalPointY, xAxisTickX, originalPointY + axisTickLength, BORDER_COLOR.SECOND);
    }

    // 折线坐标点集合
    var dataPoint = [];
    for (var _i2 = 0; _i2 < xAxisItemLength; _i2++) {
      var value = yData[_i2];
      var x = xAxisTickPointX(_i2, originalPointX, xAxisItemSpace) + xAxisItemSpaceHalf;
      var _y = originalPointY - valueHeight(value, maxValue, minValue, yAxisHeight);
      dataPoint.push({
        x: x,
        y: _y
      });
    }

    // 绘制折线
    for (var _i3 = 0; _i3 < dataPoint.length - 1; _i3++) {
      var _dataPoint$_i = dataPoint[_i3],
        _x = _dataPoint$_i.x,
        _y2 = _dataPoint$_i.y;
      var _dataPoint = dataPoint[_i3 + 1],
        nextX = _dataPoint.x,
        nextY = _dataPoint.y;
      renderLine(ctx, _x, _y2, nextX, nextY, COLOR.PRIMARY, 1);

      // 绘制拐点小圆形
      ctx.beginPath();
      ctx.arc(_x, _y2, 1, 0, Math.PI * 2, true); // 绘制
      ctx.fillStyle = COLOR.PRIMARY;
      ctx.fill();

      // 动画
      // (function(j) {
      //   setTimeout(() => {
      //     const { x, y } = dataPoint[i];
      //     const { x: nextX, y: nextY } = dataPoint[i+1];

      //     renderLine(ctx, x, y, nextX, nextY, COLOR.PRIMARY, 1)

      //     // 绘制拐点小圆形
      //     ctx.beginPath();
      //     ctx.arc(x, y, 1, 0, Math.PI * 2, true); // 绘制
      //     ctx.fillStyle = COLOR.PRIMARY;
      //     ctx.fill()
      //   }, j * 100)
      // }(i))
    }
  };

  // DOM 变更之后，渲染之前 执行
  useLayoutEffect(function () {
    var canvasEl = document.getElementById('canvas');
    var ctx = canvasEl.getContext('2d');
    var _setCanvasSize = setCanvasSize(canvasEl, style, grid.width, grid.height),
      width = _setCanvasSize.width,
      height = _setCanvasSize.height;

    // 可知条件：根据画布宽高计算
    yAxisHeight = height - (grid.top + grid.bottom);
    originalPointY = height - grid.bottom;
    yAxisTickSpace = yAxisHeight / (yAxisSplitNumber - 1);
    xAxisTopPointX = width - grid.left;
    xAxisWidth = width - grid.left - grid.right;

    // 获取到数据后再填入数据和配置项
    yData.length && renderCanvas(ctx);
  }, [yData]);
  return /*#__PURE__*/React.createElement("canvas", {
    id: "canvas",
    style: {
      backgroundColor: backgroundColor
    }
  });
};
export default Line;