import React, { useLayoutEffect } from 'react';
import { COLOR, TEXT_COLOR, BG_COLOR, BORDER_COLOR } from '../../colors/light';
import './index.css';
import { renderLine, renderText, yAxisTickText, xAxisTickPointX, valueHeight, setCanvasSize, renderRect, mergeObject, drawRoundedRect } from '../../utils/common';
var Bar = function Bar(_ref) {
  var _ref$option = _ref.option,
    option = _ref$option === void 0 ? {} : _ref$option,
    _ref$style = _ref.style,
    style = _ref$style === void 0 ? {
      width: '600px',
      height: '300px'
    } : _ref$style;
  // 默认配置项
  var defaultConfig = {
    yData: [],
    xData: [],
    // y轴分段数量
    yAxisSplitNumber: 5,
    // 背景色
    backgroundColor: BG_COLOR.BODY,
    // 对象放在...option后面做覆盖式更新
    // 坐标轴与容器间的边距
    grid: {
      left: 30,
      right: 30,
      top: 30,
      bottom: 30,
      height: 'auto',
      width: 'auto'
    },
    // 刻度相关
    axisTick: {
      length: 5,
      show: true
    }
  };
  var config = mergeObject(defaultConfig, option);
  var yData = config.yData,
    xData = config.xData,
    yAxisSplitNumber = config.yAxisSplitNumber,
    grid = config.grid,
    _config$axisTick = config.axisTick,
    tickLength = _config$axisTick.length,
    axisTickShow = _config$axisTick.show,
    backgroundColor = config.backgroundColor;

  // 初始变量
  var canvasWidth = '';
  var canvasHeight = '';
  var yAxisHeight = ''; // y轴高度
  var xAxisWidth = ''; // x轴宽度
  var yAxisTickSpace = ''; // y轴刻度间距
  var originalPointY = ''; // 原点纵坐标
  var xAxisTopPointX = ''; // x轴顶点横坐标
  var yAxisOriginPointY = ''; // y轴原点纵坐标
  var xAxisItemLength = '';

  // 初始常量
  var originalPointX = grid.left; // 原点横坐标
  var yAxisVertexY = grid.top; // y轴顶点纵坐标

  /**
   * 绘制辅助线画布
   */
  var renderTipCanvas = function renderTipCanvas() {
    console.log('绘制辅助线画布');
    var tipCanvas = document.getElementById('tipCanvas');
    var ctxTip = tipCanvas.getContext('2d');

    // 提示框内部样式配置
    var padding_horizontal = 10;
    var padding_vertical = 25;

    // 提示框元素宽度
    var tipInfoElWidth = 100;
    // 提示框高度
    var tipInfoElHeight = 50;

    // 判断鼠标是否在k线图内容区域
    var isContentArea = function isContentArea(e) {
      var offsetX = e.offsetX,
        offsetY = e.offsetY;
      return offsetX > originalPointX && offsetX < canvasWidth - grid.right && offsetY > grid.top && offsetY < yAxisOriginPointY;
    };

    // 监听鼠标移动事件并绘制辅助线
    tipCanvas.addEventListener('mousemove', function (e) {
      // 鼠标距目标节点左上角的X坐标、Y坐标
      var offsetX = e.offsetX,
        offsetY = e.offsetY;
      // 清除画布
      ctxTip.clearRect(0, 0, canvasWidth, canvasHeight);
      // 不在内容区域则不进行绘制
      if (!isContentArea(e)) return;

      // 获取x轴元素在x轴上的下标和数据
      var xTipIndex = Math.floor((offsetX - originalPointX) / xAxisWidth * xAxisItemLength);
      var label = xData[xTipIndex];
      var value = yData[xTipIndex];
      var xAxisItemWidth = xAxisWidth / xAxisItemLength;
      var xAxisTickX = xAxisTickPointX(xTipIndex, originalPointX, xAxisItemWidth);
      var dist = 10; // 提示框距离鼠标的距离
      var tipInfoPointX = offsetX + dist; //  提示框的开始横坐标
      if (offsetX > canvasWidth / 2 - grid.left) {
        tipInfoPointX = offsetX - tipInfoElWidth - dist;
      }

      // 绘制矩形背景
      ctxTip.beginPath();
      ctxTip.moveTo(xAxisTickX, yAxisVertexY);
      ctxTip.rect(xAxisTickX, yAxisVertexY, xAxisItemWidth, yAxisHeight);
      ctxTip.fillStyle = COLOR.PRIMARY;
      ctxTip.globalAlpha = 0.1;
      ctxTip.shadowBlur = 0;
      ctxTip.shadowOffsetX = 0;
      ctxTip.shadowOffsetY = 0;
      ctxTip.fill();
      ctxTip.closePath();

      // 绘制提示框
      ctxTip.beginPath();
      drawRoundedRect({
        x: tipInfoPointX,
        y: offsetY + 10,
        width: tipInfoElWidth,
        height: tipInfoElHeight
      }, 5, ctxTip);
      ctxTip.fillStyle = BG_COLOR.BODY;
      ctxTip.globalAlpha = 1;
      // 阴影
      ctxTip.shadowColor = BORDER_COLOR.SECOND;
      ctxTip.shadowBlur = 8;
      ctxTip.shadowOffsetX = 1;
      ctxTip.shadowOffsetY = 1;
      ctxTip.fill();

      // 绘制提示框内的元素
      var y = offsetY + 10 + padding_vertical;
      renderText(ctxTip, tipInfoPointX + padding_horizontal, y, label, 'left', TEXT_COLOR.PRIMARY, '13px');
      renderText(ctxTip, tipInfoPointX + padding_horizontal * 6, y, value, 'left', TEXT_COLOR.PRIMARY, '14px');
    }, false);
  };

  // 绘制画布
  var renderCanvas = function renderCanvas(ctx) {
    // 随画布元素数量变化而变化的属性
    xAxisItemLength = xData.length;
    // 最大最小值
    var maxValue = Math.max.apply(Math, yData) + 20;
    // const minValue = Math.min(...yData)
    var minValue = 0;
    var xAxisItemWidth = xAxisWidth / xAxisItemLength;
    var itemSpace = 30; // 表示x轴元素间距
    var barWidth = (xAxisWidth - itemSpace * (xAxisItemLength - 1)) / xAxisItemLength;
    var barMarginLeft = itemSpace / 2;

    // 绘制y轴文字与网格线
    for (var i = 0; i < yAxisSplitNumber; i++) {
      var y = originalPointY - yAxisTickSpace * i;

      // y轴文字
      renderText(ctx, originalPointX - 10, y, yAxisTickText(i * yAxisTickSpace, maxValue, minValue, yAxisHeight, 0), 'right', TEXT_COLOR.PRIMARY);
      // 水平网格线
      renderLine(ctx, originalPointX, y, xAxisTopPointX, y, BORDER_COLOR.SECOND);
    }

    // 绘制x轴
    var xAxisItemMaxShowNumber = 20; // 最多展示xAxisItemMaxShowNumber个
    var remainder = Math.ceil(xAxisItemLength / (xAxisItemMaxShowNumber - 1));
    renderLine(ctx, originalPointX, originalPointY, xAxisTopPointX, originalPointY, COLOR.LINE);
    // 绘制x轴刻度与文字
    for (var _i = 0; _i < xAxisItemLength; _i++) {
      var xAxisTickX = xAxisTickPointX(_i, originalPointX, xAxisItemWidth);
      if (_i % remainder === 0) {
        renderText(ctx, xAxisTickX + xAxisItemWidth / 2, originalPointY + tickLength + 10, xData[_i], 'center', TEXT_COLOR.PRIMARY);
        axisTickShow && renderLine(ctx, xAxisTickX, originalPointY, xAxisTickX, originalPointY + tickLength, BORDER_COLOR.SECOND);
      }
    }

    // 图形坐标点集合
    var dataPoint = [];
    for (var _i2 = 0; _i2 < xAxisItemLength; _i2++) {
      var value = yData[_i2];
      var x = xAxisTickPointX(_i2, originalPointX, xAxisItemWidth) + barMarginLeft;
      var _y = originalPointY - valueHeight(value, maxValue, minValue, yAxisHeight);
      dataPoint.push({
        x: x,
        y: _y
      });
    }

    // 绘制矩形
    for (var _i3 = 0; _i3 < xAxisItemLength; _i3++) {
      var _value = yData[_i3];
      var _dataPoint$_i = dataPoint[_i3],
        _x = _dataPoint$_i.x,
        _y2 = _dataPoint$_i.y;
      var h = valueHeight(_value, maxValue, minValue, yAxisHeight);
      ctx.beginPath();
      drawRoundedRect({
        x: _x,
        y: _y2,
        width: barWidth,
        height: h
      }, 3, ctx);
      ctx.fillStyle = COLOR.PRIMARY;
      ctx.globalAlpha = 0.9;
      ctx.fill();
    }
    renderTipCanvas();
  };

  // DOM 变更之后，渲染之前 执行
  useLayoutEffect(function () {
    var canvasEl = document.getElementById('canvas');
    var tipCanvasEl = document.getElementById('tipCanvas');
    if (!canvasEl.getContext) {
      console.error('该浏览器不支持展示<canvas>标签');
      return;
    }
    var ctx = canvasEl.getContext('2d');
    var _setCanvasSize = setCanvasSize(canvasEl, style, grid.width, grid.height),
      width = _setCanvasSize.width,
      height = _setCanvasSize.height;
    setCanvasSize(tipCanvasEl, style, grid.width, grid.height);

    // 可知条件：根据画布宽高计算
    canvasWidth = width;
    canvasHeight = height;
    yAxisHeight = height - (grid.top + grid.bottom);
    originalPointY = height - grid.bottom;
    yAxisTickSpace = yAxisHeight / (yAxisSplitNumber - 1);
    xAxisTopPointX = width - grid.left;
    xAxisWidth = width - grid.left - grid.right;
    yAxisOriginPointY = height - grid.bottom;

    // 获取到数据后再填入数据和配置项
    yData.length && renderCanvas(ctx);
  }, [yData]);
  return /*#__PURE__*/React.createElement("div", {
    id: "canvasWrap"
  }, /*#__PURE__*/React.createElement("canvas", {
    id: "canvas",
    style: {
      backgroundColor: backgroundColor
    }
  }), /*#__PURE__*/React.createElement("canvas", {
    id: "tipCanvas"
  }));
};
export default Bar;